import re

# 'Hello, world!' 문자열에 'Hello'와 'Python'이 있는지 판단합니다.
print(re.match('Hello', 'Hello, world!'))

# 문자열 앞에 ^를 붙이면 문자열이 맨 앞에 오는지 판단하고,
# 문자열 뒤에 $를 붙이면 문자열이 맨 뒤에 오는지 판단합니다(특정 문자열로 끝나는지).
# 단, 이때는 match 대신 search 함수를 사용해야 합니다.
# match 함수는 문자열 처음부터 매칭되는지 판단하지만 search는 문자열 일부분이 매칭되는지 판단합니다.
print(re.search('^Hello', 'Hello, world!'))
print(re.search('world!$', 'Hello, world!'))

# 이번에는 여러 문자열(문자) 중 하나라도 포함되어 있는지 판단해보겠습니다.
# 이때는 |를 사용하여 문자열을 나열합니다. 기본 개념은 OR 연산자와 같습니다.
print(re.match('hello|world', 'hello'))

# 이번에는 문자열이 숫자로 되어있는지 판단해보겠습니다.
# 다음과 같이 [ ](대괄호) 안에 숫자 범위를 넣으며 * 또는 +를 붙입니다.
# 범위는 0-9처럼 표현하며 *는 문자(숫자)가 0개 이상 있는지, +는 1개 이상 있는지 판단합니다.
print(re.match('[0-9]*', '1234'))
print(re.match('[0-9]+', '1234'))
print(re.match('[0-9]+', 'abcd'))

# * 와 + 의 활용방법에 대하여 확인해보는 코드
# a*b, a+b에서 b는 무조건 있어야 하는 문자고, a*는 a가 0개 이상 있어야 하므로 b는 매칭이 됩니다.
# 하지만 a+는 a가 1개 이상 있어야 하므로 b는 매칭되지 않습니다.
# 그리고 'ab', 'aab', 'aaab'처럼 a가 0개 이상 또는 1개 이상 있을 때는 a*b와 a+b를 모두 만족합니다.
print(re.match('a*b', 'b'))
print(re.match('a+b', 'b'))
print(re.match('a*b', 'aab'))
print(re.match('a+b', 'aab'))

# ? 와 . 의 활용방법에 대하여 확인해보는 코드
# ?는 문자 0개 또는 1개인지 판단하고, .는 문자 1개인지 판단합니다.
# 다음의 코드가 모두 matching되는 이유는 H 뒤에 몇개의 문자가 오는지 판단하기 때문이다.
# ? 의 경우 H뒤에 문자가 0개 또는 1개인지 판단하고, .의 경우 H뒤에 문자가 1개만 있는지 판단한다.
# .의 경우 H 문자 뒤에 문자가 존재하지 않을 경우 None을 뱉어낸다
print(re.match('H?', 'H'))
print(re.match('H?', 'Hi'))
print(re.match('H.', 'Hi'))

# 그럼 문자(숫자)가 정확히 몇 개 있는지 판단하고 싶을 수도 있겠죠?
# 이때는 문자열이나 범위 [ ] 뒤에 {개수} 형식을 지정합니다.
# 다음은 휴대전화의 번호 형식에 맞는지 판단합니다.
print(re.match('[0-9]{3}-[0-9]{4}-[0-9]{4}', '010-1000-1000'))
print(re.match('[0-9]{3}-[0-9]{4}-[0-9]{4}', '010-1000-100'))
# 이 기능은 문자(숫자)의 개수 범위도 지정할 수 있습니다.
# {시작개수,끝개수} 형식으로 시작 개수와 끝 개수를 지정해주면 특정 개수 사이에 들어가는지 판단합니다.
# 다음은 일반전화의 번호 형식에 맞는지 판단합니다.
print(re.match('[0-9]{2,3}-[0-9]{3,4}-[0-9]{4}', '02-100-1000'))
print(re.match('[0-9]{2,3}-[0-9]{3,4}-[0-9]{4}', '02-10-1000'))

# 영문 문자를 조합해서 판단할 수도 있다
print(re.match('[a-zA-Z0-9]+', 'Hello1234'))  # a부터 z, A부터 Z, 0부터 9까지 1개 이상 있으므로 패턴에 매칭됨
print(re.match('[A-Z0-9]+','hello')) # 대문자, 숫자는 없고 소문자만 있으므로 패턴에 매칭되지 않음

# 이처럼 숫자, 영문 문자 범위는 a-zA-Z0-9, A-Z0-9와 같이 붙여 쓰면 됩니다.
# 그럼 한글은 어떻게 사용할까요? 영문 문자와 방법이 같습니다.
# 가-힣처럼 나올 수 있는 한글 조합을 정해주면 됩니다.
print(re.match('[가-힣]+', '홍길동'))

# 그럼 특정 문자 범위에 포함되지 않는지 판단하려면 어떻게 해야 할까요?
# 다음과 같이 문자(숫자) 범위 앞에 ^를 붙이면 해당 범위를 제외합니다.
# 즉, '[^A-Z]+'는 대문자를 제외한 모든 문자(숫자)가 1개 이상 있는지 판단합니다.
print(re.match('[^A-Z]+', 'Hello'))  # 대문자를 제외. 대문자가 있으므로 패턴에 매칭되지 않음
print(re.match('[^A-Z]+', 'hello'))  # 대문자를 제외. 대문자가 없으므로 패턴에 매칭됨
# 앞에서 특정 문자열로 시작하는지 판단할 때도 ^를 사용했었는데 문법이 비슷해서 이 부분은 헷갈리기 쉽습니다.
# 범위를 제외할 때는 '[^A-Z]+'와 같이 [ ] 안에 넣어주고,
# 특정 문자 범위로 시작할 때는 '^[A-Z]+'와 같이 [ ] 앞에 붙여줍니다.
# 그래서 다음과 같이 '^[A-Z]+'는 영문 대문자로 시작하는지 판단합니다.
print(re.search('^[A-Z]+', 'Heool'))
print(re.search('[0-9]+$', 'Hello1234'))

 # 정규표현식에 사용하는 특수 문자 *, +, ?, ., ^, $, (, ) [, ], - 등을 판단하려면 어떻게 해야 할까요?
 # 특수 문자를 판단할 때는 특수 문자 앞에 \를 붙이면 됩니다.
 # 단, [ ] 안에서는 \를 붙이지 않아도 되지만 에러가 발생하는 경우에는 \를 붙입니다.
print(re.search('\*+', '1 **2')) # *이 들어있는지 판단
print(re.match('[$()a-zA-Z0-0]+', '$(document)')) # $, (, )와 문자, 숫자가 들어있는지 판단

# 지금까지 범위를 지정하면서 a-zA-Z0-9처럼 대소문자와 숫자를 모두 나열했습니다.
# 이런 방식으로 범위를 정하면 정규표현식이 길어지고 복잡해집니다.
# 단순히 숫자인지 문자인지 판단할 때는 \d, \D, \w, \W를 사용하면 편리합니다.
# \d: [0-9]와 같음. 모든 숫자
# \D: [^0-9]와 같음. 숫자를 제외한 모든 문자
# \w: [a-zA-Z0-9_]와 같음. 영문 대소문자, 숫자, 밑줄 문자
# \W: [^a-zA-Z0-9_]와 같음. 영문 대소문자, 숫자, 밑줄 문자를 제외한 모든 문자
print(re.match('\d+', '1234'))
print(re.match('\D+', 'Hello'))
print(re.match('\w+', 'Hello_1234')) # 영문 대소문자, 숫자, 밑줄 문자이므로 패턴에 매칭됨
print(re.match('\W+', '(:)'))  # 영문 대소문자, 숫자, 밑줄문자를 제외한 모든 문자이므로 패턴에 매칭됨

# 공백은 ' '처럼 공백 문자를 넣어도 되고, \s 또는 \S로 표현할 수도 있습니다.
# \s: [ \t\n\r\f\v]와 같음. 공백(스페이스), \t(탭) \n(새 줄, 라인 피드), \r(캐리지 리턴), \f(폼피드), \v(수직 탭)을 포함
# \S: [^ \t\n\r\f\v]와 같음. 공백을 제외하고 \t, \n, \r, \f, \v만 포함
print(re.match('[a-zA-Z0-9 ]+', 'Hello 1234')) # ' '로 공백 표현
print(re.match('[a-zA-Z0-9\s]+', 'Hello 1234')) # \s로 공백 표현

# 정규표현식 컴파일해서 사용하기
# 매번 match나 search 함수에 정규표현식 패턴을 지정하는 방법은 비효율적입니다.
# 같은 패턴을 자주 사용할 때는 compile 함수를 사용하여 정규표현식 패턴을 객체로 만든 뒤
# match 또는 search 메서드를 호출하면 됩니다.
p = re.compile('[0-9]+')
print(p.match('1234')) # re.match('[0-9]+', '1234')를 실행시킨 것과 같다.
print(p.search('hello')) # re.match('[0-9]+', 'hello')를 실행시킨 것과 같다.

# 지금까지 정규표현식 하나로만 매칭 여부를 판단했습니다. 이번에는 정규표현식을 그룹으로 묶는 방법을 알아보겠습니다.
# 정규표현식 그룹은 해당 그룹과 일치하는 문자열을 얻어올 때 사용합니다.
# 패턴 안에서 정규표현식을 ( )(괄호)로 묶으면 그룹이 됩니다.
# 다음은 공백으로 구분된 숫자를 두 그룹으로 나누어서 찾은 뒤 각 그룹에 해당하는 문자열(숫자)을 가져옵니다
 # groups 메서드는 각 그룹에 해당하는 문자열을 튜플로 반환합니다.
m = re.match('([0-9]+) ([0-9]+)', '10 295')
print(m.group(1)) # 첫 번째 그룹(그룹 1)에 매칭된 문자열을 반환
print(m.group(2)) # 두 번째 그룹(그룹 2)에 매칭된 문자열을 반환
print(m.group()) # 매칭된 문자열을 한꺼번에 반환
print(m.group(0)) # 매칭된 문자열을 한꺼번에 반환

# 그룹 개수가 많아지면 숫자로 그룹을 구분하기가 힘들어집니다.
# 이때는 그룹에 이름을 지으면 편리합니다. 그룹의 이름은 ( )(괄호) 안에 ?P<이름> 형식으로 지정합니다.
m = re.match('(?P<func>[a-zA-Z_][a-zA-Z0-9_]+)\((?P<arg>\w+)\)', 'print(1234)')
print(m.group('func'))
print(m.group('arg'))
# (?P<func>)와 (?P<arg>)처럼 각 그룹에 이름을 짓고 m.group('func'), m.group('arg')로 매칭된 문자열을 출력했습니다.
# 참고로 함수 이름은 문자로만 시작해야 하므로 첫글자는 [a-zA-Z_]로 판단해줍니다.
# 또한, print 뒤에 붙은 (, )는 정규표현식에 사용하는 특수 문자이므로 앞에 \를 붙여줍니다.

# 지금까지 그룹에 해당하는 문자열을 가져왔습니다. 그러면 그룹 지정 없이 패턴에 매칭되는 모든 문자열을 가져오려면 어떻게 해야 할까요?
# 이때는 findall 함수를 사용하며 매칭된 문자열을 리스트로 반환합니다.
print(re.findall('[0-9]+', '1 2 Fizz 4Buzz Fizz 7 8'))

# 그룹과 *, + 활용하기
# +과 *을 조합하여 사용할 때는 그룹으로 묶어서 사용합니다.
# (.[a-z]+)*는 점과 영문 소문자가 1개 이상 있는지 판단하고, 이것 자체가 0개 이상인지 판단합니다.
# 즉, 규칙은 반드시 지켜야 하지만 있어도 되고 없어도 되는 상황에 사용합니다.
print(re.match('[a-z]+(.[a-z]+)*$', 'hello.world')) # .world는 문자열이므로 패턴에 매칭됨
print(re.match('[a-z]+(.[a-z]+)*$', 'hello.1234')) # .1234는 숫자이므로 패턴에 매칭되지 않음
print(re.match('[a-z]+(.[a-z]+)*$', 'hello.hello')) # .뒤에 문자열이 없어도 패턴에 매칭됨

# 이번에는 정규표현식으로 특정 문자열을 찾은 뒤 다른 문자열로 바꾸는 방법을 알아보겠습니다.
# 문자열을 바꿀 때는 sub 함수를 사용하며 패턴, 바꿀 문자열, 문자열, 바꿀 횟수를 넣어줍니다.
# 여기서 바꿀 횟수를 넣으면 지정된 횟수만큼 바꾸며 바꿀 횟수를 생략하면 찾은 문자열을 모두 바꿉니다.
# re.sub(패턴, 바꿀문자열, 문자열, 바꿀횟수)
print(re.sub('apple|orange', 'fruit', 'apple box orange tree'))
print(re.sub('[0-9]+', 'n', '1 2 Fizz 4 Buzz Fizz 7 8'))

# sub 함수는 바꿀 문자열 대신 교체 함수를 지정할 수도 있습니다.
# 교체 함수는 매개변수로 매치 객체를 받으며 바꿀 결과를 문자열로 반환하면 됩니다.
# 다음은 문자열에서 숫자를 찾은 뒤 숫자를 10배로 만듭니다.
# mutiple10 함수에서 group 메서드로 매칭된 문자열을 가져와서 정수로 바꿉니다.
# 그리고 숫자에 10을 곱한 뒤 문자열로 변환해서 반환했습니다.
def multiple10(m):
    n = int(m.group())
    return str(n*10) # 숫자에 10을 곱한 뒤 문자열로 변환해서 반환
print(re.sub('[0-9]+', multiple10,  '2 Fizz 4 Buzz Fizz 7 8'))
# 람다표현식으로도 가능
print(re.sub('[0-9]+', lambda m: str(int(m.group())*10), '1 2 Fizz 4 Buzz Fizz 7 8'))

# 이번에는 정규표현식으로 찾은 문자열을 가져와서 결과에 다시 사용해보겠습니다.
# 먼저 정규표현식을 그룹으로 묶습니다. 그리고나면 바꿀 문자열에서 \\숫자 형식으로 매칭된 문자열을 가져와서 사용할 수 있습니다.
# 다음은 'hello 1234'에서 hello는 그룹 1, 1234는 그룹 2로 찾은 뒤 그룹 2, 1, 2, 1 순으로 문자열의 순서를 바꿔서 출력합니다.
print(re.sub('([a-z]+) ([0-9]+)', '\\2 \\1 \\2 \\1', 'hello 1234'))
print(re.sub('({\s*)"(\w+)":\s*"(\w+)"(\s*})', '<\\2>\\3</\\2>', '{ "name": "james" }'))
print(re.sub('({\s*)"(?P<key>\w+)":\s*"(?P<value>\w+)"(\s*})', '<\\g<key>>\\g<value></\\g<key>>', '{ "name": "james" }'))
