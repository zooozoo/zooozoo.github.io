---
title: 독하게시작하는 c프로그래 강의 노트
excerpt: >-
 컴퓨터 구조를 이해하기 위해 c언어라는 산을 한번 넘어보고 싶었습니다. 그 산을 넘는 첫 번째 과정입니다.
 언어 그 자체보다 컴퓨터구조를 공부하는데에 도움이 되는 방향으로 공부합니다.
---
# 제1장 c프로그래밍 입문

### 오류해결 사례

`f7`키를 통해서 빌드할 때 아래와 같은 에러 발생

> c:\apiexam\firsts\firsts\firsts.cpp(46): fatal error C1010: 미리 컴파일된 헤더를 찾는 동안 예기치 않은 파일의 끝이 나타났습니다. '#include "StdAfx.h"'을(를) 소스에 추가하시겠습니까?

* 검색을 통해 문제 해결
  * [링크](https://social.msdn.microsoft.com/Forums/ko-KR/cc067d9f-3c6e-4ca6-a5ce-68114a428da3/visual-c-487164630044032-50504461214576845796?forum=visualcplusko)
  * 해결방법
    1. 프로젝트의 솔루션 탐색기 창에서 마우스 오른쪽 단추로 프로젝트 이름을 클릭한 다음 속성을 클릭합니다.  
    2. 왼쪽 창에서 C/C++ 폴더를 클릭합니다.   
    3. 미리 컴파일된 헤더 노드를 클릭합니다.  
    4. 오른쪽 창에서 미리 컴파일된 헤더 만들기/사용을 클릭한 다음 미리 컴파일된 헤더 사용 안 함을 클릭합니다.  

### 강의 중 기록사항

강의중 나온 단축키 설명

* `f7`  : 빌드
* `ctrl` + `f5` : 디버깅 하지 않고 실행 (내용을 확이할 수 있도록 실행 결과가 창에 떠있음)

# 제3장 표준 입/출력 도구 첫 번째

* ux의 시대에도 cli와 같은 근본적인 입출력은 잘 알아야 한다. 결국 정보란 문자열이기 때문에
* getchar()
  * 어디서 어떻게 가져오는지 알아보자
* 컴퓨터의 구조에 대해서 생각해 보자
  * 컴퓨터
    * 하드웨어
    * 소프트 웨어
      * 시스템 소프트웨어 (ex: os)
      * 응용 소프트웨어
  * 컴퓨터의 계층(국가를 예시로 영토, 정부, 가구로 설명함)
    1. 하드웨어
    2. 커널 os
       * 디바이스를 제어하는 `디바이스 드라이버` 커널 소프트웨어
    3. 유저 user/ 프로세스
       * 프로세스는 각각의 영역을 보장 받는다.
       * 그러나 프로세스가 할당받은 영역을 제어할 수 있는 소프트웨어가 있는데 `디버거`라고 한다.
       * 다른프로세스의 메모리를 변조하는 공격을 메모리 해킹이라고 하는데 이것을 `디버거`로 한다. 또한 소프트웨어의 문제를 해결하는 것 또한 `디버거`
       * 유저모드에서 커널모드로의 진입은 불가
       * 커널과 연결할 수 있는 추상화된 인터페이스 -> 파일(File)
       * 파일은 파일마다 고유한 입출력 버퍼를 가지고 있다. (즉 메모리를 가지고 있다.)
         1. write
            * ex) putchar('A')를 할 경우 'A'라는 버퍼를 체우게 되는데 이것을 버퍼링이라고 한다.
         2. read
            * ex) getchar()함수는 버퍼로 부터 한 글자를 퍼올리는역할을 한다.
       * 파일을 알맞은 규칙에 맞게 작성해서 커널로 전달하면 커널이 다시 하드웨어를 작동시킨다. 이때에 규칙이 `Protocol`(protocol은 정보전달 규약)
       * 파일 입출력의 다양한 규칙을 맞추기 어려우니 하나의 함수 형태로 만들어 놓은게 getchar(), putchar() 함수다.
       * 만약 프로토콜이 TCP일 경우, 프로토콜 서비스를 추상화한 파일의 경우 특별하게 `socket`이라고 한다.
       * 소켓은 정보를 수신할 때 언제 수신할지 모르기 때문에 비동기 방식을 체택한다.
  * c언어는 컴퓨터의 모든부분을 커버할 수 있다.
* 입출력 (I/O)을 수행하는 주체 -> 커널
* putchar() - 입출력을 요구하는 함수
* 입출력은 user모드 어플리케이션에서 요구하고 -> 커널이 입출력을 담당한다.
* 소캣프로그래밍을 잘하고 싶다면 시스템 프로그래밍 + file I/O + Protocol  이렇게 하면 된다.
* putchar, getchar는 버퍼드I/O를 한다.
* getchar()함수의 작동 과정
  * 하드웨어에서(ex, 키보드) 'hello'를 입력받으면 장치드라이버와 인터페이스를 통해 파일을 추상화 한 후 해당 파일로 부터 꺼내서 read를 하게 된다. 파일마다 I/O 버퍼가 존재한다. 버퍼에 'hello가 쌓이게 됨' -> 이런 상황에서 getchar함수를 실행하면 'h'를 끄집어 내서 'char'형식으로 반환한다.  그런데 getchar함수의 원형은 int를 반환하게 되어있음 (char + int는 int가 된다.)
* 버퍼와, 버퍼링
  * 버퍼
    * 메모리
    * 데이터를 한 곳에서 다른 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리 영역
    * 사전적 정의는 '완충기'
  * 버퍼링
    * 정보 전달 과정에서 정보를 소비하는 쪽에서 정보 전달에 문제가 생긴 상황을 모르게 하는 것
    * 버퍼를 활용하는 방식 또는 버퍼를 채우는 동작을 말한다. 다른 말로는 '큐'라고도 표현한다.
* 논버퍼드 I/O
  * 정보가 전달 될 때 복사되서 전달하는게 아니라 한번에 어떤 장치와 cpu가 직접 정보를 전달하게 되면 더 빠른 정보 전달이 가능하다.
  * DMA - Direct Memory Access
* 버퍼드 I/O를 하는 함수
  * 하드웨어 -> 콘솔 -> 파일을 통해 버퍼에 정보가 쌓인다.
  * getchar() - 버퍼에서 한글자씩 빼오는거
  *  scanf() - 형식문자 규칙에 맞게 빼오는거 / 보안결함이 있기 때문에 scanf_s()를 사용하세요, 단 리눅스에는 없습니다. 윈도우에만 있습니다.
  *  gets() - 버퍼에서 한줄씩 빼오는거 / 보안결함이 있기 때문에 gets_s()를 사용하세요
* 논버퍼드 I/O
  * -getch()
  * 버퍼에서 정보를 읽어오는 것이 아니라, 하드웨어 에서의 인터럽트를 즉시wait하고 있음
* fflush()
  * 버퍼를 비우는 함수
  * 원래는 output만 되는데 윈도우는 input도 됨
