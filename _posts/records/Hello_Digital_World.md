# 커니핸 교수의 Hello Digital World 공부

###  소프트웨어의 계층

```
하드웨어
커널
운영체제
라이브러리집합(API를 통해 접근 가능)
애플리케이션

```

> 운영 체제와 애플리케이션 사이의 경계는 뚜렷하게 정의되어 있지 않다. 완벽하진 않아도 유용한 지침은 한 애플리케이션이 다른 애플리케이션을 간섭하지 않도록 보장하는 데 필요한 것은 무엇이든 운영체제의 일부라는 점이다. 메모리 관리, 즉 프로그램이 실행되는 동안 메모리 어디에 프로그램을 둘지 결정하는 일은 운영 체제의 일부다. 마찬가지로 디스크 어디에 정보를 저장할 것인지 결정하는 파일 시스템은 핵심적인 기능이다. 장치의 제어도 마찬가지다. 두 개의 애플리케이션이 프린터를 동시에 작동시킬 수 있어서는 안 되고, 중간 조정 없이 디스플레이에 값을 기록해서도 안된다. 중심에서 CPU를 제어하는 일은 운영 체제의 기능인데 다른 모든 속성을 보장하기 위해 필요한 일이기 때문이다.
>
> (발췌)

다시 이야기 하면 애플리케이션이 컴퓨터 자원을 사용하는데 있어서 다른 애플리케이션의 간섭을 받지 않고 독립적으로 우영될 수 있도록 도와주는 일은 운영 체제의 영역.

아래는 구글에서 `소프트웨어 계층`이라는 단어로 검색했을 때 위키백과에  위키 백과에서 설명하는 `추상화 계층`

> **추상화 계층**(abstraction layer)은 특정한 집합의 기능의 자세한 부분을 숨기는 한 방법이다. 추상화 계층을 이용하는 소프트웨어 모델에는 [컴퓨터 네트워크](https://ko.wikipedia.org/wiki/%EC%BB%B4%ED%93%A8%ED%84%B0_%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC) [통신 프로토콜](https://ko.wikipedia.org/wiki/%ED%86%B5%EC%8B%A0_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C)을 위한 [OSI 7개 계층 모형](https://ko.wikipedia.org/wiki/OSI_%EB%AA%A8%ED%98%95), [OpenGL](https://ko.wikipedia.org/wiki/OpenGL) 그래픽 드로잉 라이브러리, [유닉스](https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%89%EC%8A%A4)가 기원이고 [MS-DOS](https://ko.wikipedia.org/wiki/MS-DOS), [리눅스](https://ko.wikipedia.org/wiki/%EB%A6%AC%EB%88%85%EC%8A%A4), 그 밖의 현대 [운영 체제](https://ko.wikipedia.org/wiki/%EC%9A%B4%EC%98%81_%EC%B2%B4%EC%A0%9C) 대부분이 채택한 [바이트 스트림](https://ko.wikipedia.org/w/index.php?title=%EB%B0%94%EC%9D%B4%ED%8A%B8_%EC%8A%A4%ED%8A%B8%EB%A6%BC&action=edit&redlink=1) 입출력(I/O) 모형이 있다.
>
> 유닉스 운영 체제에서 대부분의 종류의 입출력 기능은 [장치](https://ko.wikipedia.org/wiki/%EC%9E%A5%EC%B9%98)로부터 읽어들이거나 장치로 기록된 바이트의 스트림으로 간주된다. 이러한 바이트 모델의 스트림은 [장치 독립](https://ko.wikipedia.org/w/index.php?title=%EC%9E%A5%EC%B9%98_%EB%8F%85%EB%A6%BD&action=edit&redlink=1)을 목적으로 파일 입출력, 소켓 입출력, 터미널 입출력에 쓰인다. 응용 프로그램 수준에서 장치로 읽기/쓰기를 하기 위해 프로그램은 장치(터미널과 같은 실제 장치나, [파일 시스템](https://ko.wikipedia.org/wiki/%ED%8C%8C%EC%9D%BC_%EC%8B%9C%EC%8A%A4%ED%85%9C)의 파일, 또는 [네트워크 포트](https://ko.wikipedia.org/wiki/%EC%BB%B4%ED%93%A8%ED%84%B0_%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4_%ED%8F%AC%ED%8A%B8)와 같은 [가상 장치](https://ko.wikipedia.org/w/index.php?title=%EA%B0%80%EC%83%81_%EC%9E%A5%EC%B9%98&action=edit&redlink=1)) 열기 명령을 호출한다. 이 장치의 물리적 특성은 운영 체제가 중재하며 프로그래머가 장치로부터 바이트를 읽거나 쓰기할 수 있게 하는데 이를 [추상화](https://ko.wikipedia.org/wiki/%EC%B6%94%EC%83%81%ED%99%94_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)) [인터페이스](https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4_(%EC%BB%B4%ED%93%A8%ED%8C%85))라고 한다. 그 뒤 운영 체제는 바이트 스트림을 장치로 읽거나 쓸 수 있도록 실제 [변형](https://ko.wikipedia.org/w/index.php?title=%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8_%EB%B3%80%ED%98%95&action=edit&redlink=1) 과정을 수행한다.
>
> [(위키백과 발췌)](https://ko.wikipedia.org/wiki/%EC%B6%94%EC%83%81%ED%99%94_%EA%B3%84%EC%B8%B5)

### 자바스크립트 예제 중 변수에 대해서

>  변수란 프로그램이 실행되는 동안 프로그램이 값을 저장할 수 있는 RAM상의 장소를 뜻한다. 프로그램이 무엇을 하는지에 따라 값이 변경될 수 있기 때문에 변수라고 한다. 변수를 선언하는 것은 모형 어셈블리 언어에서 했던 것처럼 메모리 위치에 이름을 지정하는 일의 고수준 언어 버전이다. 은유적으로, 선언문은 '등장인물들'로, 희곡에 나오는 인물의 목록이다.
>
>  (발췌)

[위키백과](https://ko.wikipedia.org/wiki/%EB%B3%80%EC%88%98_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99))에서의 변수에 대한 정의

>[컴퓨터 프로그래밍](https://ko.wikipedia.org/wiki/%EC%BB%B4%ED%93%A8%ED%84%B0_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)에서 **변수**(變數) 또는 **스칼라**(scalar)는 아직 알려지지 않거나 어느 정도까지만 알려져 있는 양이나 정보에 대한 상징적인 이름이다. 컴퓨터 [소스 코드](https://ko.wikipedia.org/wiki/%EC%86%8C%EC%8A%A4_%EC%BD%94%EB%93%9C)에서의 변수 이름은 일반적으로 [데이터 저장 위치](https://ko.wikipedia.org/wiki/%EB%A9%94%EB%AA%A8%EB%A6%AC_%EC%A3%BC%EC%86%8C)와 그 안의 내용물과 관련되어 있으며 이러한 것들은 프로그램 실행 도중에 변경될 수 있다.
>
>프로그래밍에서의 변수는 수학에서 말하는 [변수](https://ko.wikipedia.org/wiki/%EB%B3%80%EC%88%98)의 개념과 완전히 일치하지 않을 수도 있다. 컴퓨터 변수의 값은 수학에서처럼 [등식](https://ko.wikipedia.org/wiki/%EB%93%B1%EC%8B%9D)이나 [공식](https://ko.wikipedia.org/wiki/%EA%B3%B5%EC%8B%9D)의 필수적인 부분이 아니다. 컴퓨터 환경에서 변수는 반복적인 과정 안에서 이용할 수도 있다. 이를테면 한 장소의 값을 할당한 뒤 어느 곳에서 사용한 다음 새로운 값으로 다시 할당하고 같은 방법으로 다시 사용할 수도 있다. 컴퓨터 프로그래밍에서의 변수는 긴 이름이 자주 나오며, 어떻게 이용할 것인지에 대한 설명을 나타내는 반면 수학에서의 변수는 짧은 시간 동안 쓰이는 간결한, 한 두 개 문자 이름이다.
>
>[컴파일러](https://ko.wikipedia.org/wiki/%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC)는 변수의 상징적인 이름을 데이터의 실제 위치로 치환해야 한다. 변수 값, 형, 위치는 일반적으로 고정된 채 유지되는 반면 위치에 저장되어 있는 데이터는 프로그램 실행 도중 변경될 수 있다.

[위키백과](https://ko.wikipedia.org/wiki/%EB%A9%94%EB%AA%A8%EB%A6%AC_%EC%A3%BC%EC%86%8C)에서의 메모리 주소에 대한 내용

>[컴퓨터 과학](https://ko.wikipedia.org/wiki/%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)에서 **메모리 주소**는 [메모리](https://ko.wikipedia.org/wiki/%EB%A9%94%EB%AA%A8%EB%A6%AC) 위치에 대한 식별자로, [컴퓨터 프로그램](https://ko.wikipedia.org/wiki/%EC%BB%B4%ED%93%A8%ED%84%B0_%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4)이나 하드웨어 장치가 데이터를 저장하고 나중에 이를 가져오는 장소이다. 일반적으로 이는 [이진](https://ko.wikipedia.org/wiki/%EC%9D%B4%EC%A7%84%EB%B2%95) 형태의 [숫자](https://ko.wikipedia.org/wiki/%EC%88%98_(%EC%88%98%ED%95%99))로 되어 있다.
>
>컴퓨터 프로그램에서 **절대 주소**는 메모리 위치를 식별하는 메모리 고유 주소이다. 즉, [기억장치](https://ko.wikipedia.org/wiki/%EA%B8%B0%EC%96%B5%EC%9E%A5%EC%B9%98) 고유의 번지로서, 기억장치 중 기억장소를 직접 숫자로 지정하는 주소역할을 한다. [기계어](https://ko.wikipedia.org/wiki/%EA%B8%B0%EA%B3%84%EC%96%B4) 정보가 기억되어 있으며, 1,2,3,4…와 같이 16진수로 약속하여 순서대로 결정한다. 반면 **상대 주소**는 고유 주소가 아니며, 특정 영역에 상대적인 주소를 지정한다.

### 광케이블에 대하여

광케이블

> **광케이블**(光cable, optical cable)이란 [광섬유](https://ko.wikipedia.org/wiki/%EA%B4%91%EC%84%AC%EC%9C%A0)를 이용한 하나의 [통신 매체](https://ko.wikipedia.org/w/index.php?title=%ED%86%B5%EC%8B%A0_%EB%A7%A4%EC%B2%B4&action=edit&redlink=1)이다. 광케이블은 [구리선](https://ko.wikipedia.org/w/index.php?title=%EA%B5%AC%EB%A6%AC%EC%84%A0&action=edit&redlink=1)을 사용하는 통신방식보다 자료 [전송속도](https://ko.wikipedia.org/wiki/%EC%A0%84%EC%86%A1%EC%86%8D%EB%8F%84)가 수십 배로 빠르나, [네트워크](https://ko.wikipedia.org/wiki/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC)를 새로 구축해야 한다는 단점이 있다.
>
> (위키백과 발췌)

광섬유

> 광학섬유라고도 한다. 이 현상을 이용하여 빛을 전송할 때 광손실을 줄이기 위하여 투명도가 고도로 높은 재료가 필요하며, 고순도의 석영이나 광학적 성질이 우수한 고분자재료를 사용한다. 광섬유는 1970년에 미국의 코닝사가 저손실석영섬유를 개발한 것을 계기로 개량을 거듭하여 광통신의 실용화에 크게 이용되고 있다.
>
> 광통신은 광섬유의 한쪽 끝에서 전기신호를 따라 점멸하는 발광소자를 써서 빛을 점멸하면 광섬유의 다른 쪽 끝에서 수광소자를 써서 이 점멸하는 빛을 받을 수 있는 현상을 이용한 것이다. 수광소자로서 포토다이오드를 쓰면 점멸하는 빛의 신호를 전기신호로 바꿀 수 있고, 발광소자로는 1초 동안에 4억 회나 점멸할 수 있는 발광다이오드도 개발되어 있다. 이 발광소자를 쓰면 광섬유 하나로써 5,760회선의 전화통화가 가능해진다.

광케이블은 광섬유를 이용한 것인데 전기 신호를 빛으로의 점멸로 바꾸고 광섬유로 보내서 한쪽 끝에서는 점멸하는 빛을 받아서 전기신호로 바꾸는 것

이런 기술을 통해서 멀리 떨어진 사람들과 통신할 수 있다는 사실에 대해서 너무나 놀랍고, 이런기술을 만들어낸 기술자들에 대해서 경외심을 가지게 된다.

### 이더넷

> 컴퓨터끼리 연결하거나 프린터 같은 공유 자원에 연결하기 위해 1970년대 초 로버트 메트칼프와 데이빗 바그스가 발명한 네트워킹 기술.
>
> (발췌요약)

### 패킷

> 이더넷에 대한 정보는 패킷으로 전송된다. 패킷(packet)은 정보를 전송하기 위해 담아 두었다가 수신되면 열어 볼 수 있도록 정확히 정의된 형식으로 정보를 담고 있는 일련의 비트 또는 바이트다. 패킷이 발신자 주소, 수신자 주소, 내용, 여러가지 기타 정보가 표준 형식으로 구성돼 있는 봉투(또는 아마도 엽서)라고 생각하면 상당히 적절한 비유라고 볼 수 있고, 페덱스 같은 택배 회사에서 이용하는 표준화된 포장용 상자도 괜찮은 비유다.
>
> (발췌)

### 프로토콜

> 광섬유, 이더넷, 무선 등 서로 다른 물성을 가지고 서로 멀리 떨어져 있을지 모를 네트워크를 어떻게 연결할까? 네트워크와 컴퓨터를 식별하고 조회할 수 있도록 이름과 주소가 필요한데, 전화번호부에서 이름으로 전화번호를 찾는 것과 비슷한 방식을 사용한다. 또한 직접 연결되지 않은 네트워크 사이의 경로를 찾을 수 있어야 한다. 정보가 이동함에 따라 그 형식이 어떻게 바뀌는지, 그리고 오류, 지연, 과부하에 대처하는 것 같은 다수의 다른 덜 명백한 문제에 대해 합의를 봐야한다. 그러한 합의가 없으면 통신하기가 어렵거나 심지어 불가능 할 수 있다.
>
> 누가 먼저 말하고 어떤 응답이 이어질 수 있는지, 오류를 어떻게 처리할 것인지 등 데이터 형식에 대한 합의는 모든 네트워크에서 `프로토콜`을 이용하여 처리되는데, 인터넷에서는 특히 더 그렇다. `프로토콜`은 일반적인 담화에서와 어느 정도 같은 의미를 지닌다. 즉, 상대방과 소통하기 위한 일련의 규칙이다. 하지만 네트워크 프로토콜은 사회적 관습이 아닌 기술적 고려 사항을 기반으로 하며, 가장 엄격한 사회 구조의 규칙보다도 훨씬 더 엄밀하게 정의된다.
>
> 규칙이 완전히 명백하지는 않을 수도 있지만, 인터넷은 그러한 규칙을 강하게 필요로 한다. 정보를 형식화하는 방법, 컴퓨터 간에 정보를 교환하는 방법, 컴퓨터를 식별하고 인증하는 방법, 무언가가 실패할 때 수행할 작업에 대한 프로토콜 및 표준에 모두 동의해야 한다.
>
> (발췌)

### 인터넷 개요

> 오늘날 인터넷은 느슨하게 연결된 수백만 개의 독립적인 네트워크로 구성된다. 가까이 있는 컴퓨터들은 근거리 통신망(종종 무선 이더넷)으로 연결된다. 다음으로 네트워크는 하나의 네트워크에서 다음 네트워크로 정보 패킷을 라우팅하는 특수한 컴퓨터인 `게이트웨이` 또는 `라우터`를 통해 다른 네트워크에 연결된다. 게이트웨이는 라우팅 정보를 교환하여 적어도 국지적인 방식으로라도 무엇이 연결되어 있고 그래서 접근 가능한지 알게 된다.
>
> 각 네트워크는 가정, 사무실, 기숙사에 있는 컴퓨터와 전화 같은 많은 호스트 시스템을 연결할 수도 있다. 가정 내의 개별 컴퓨터는 라우터에 연결하기 위해 무선을 사용할 가능성이 있고, 라우터는 케이블이나 DSL로 인터넷 서비스 제공업체(Internet Service Provider), 즉 ISP에 연결된다. 반변 사무실에 있는 컴퓨터는 유선 이더넷 연결을 사용할 수도 있다.
>
> (발췌)

### IP 패킷

> 이전 장에서 언급했듯이 정보는 패킷이라고 하는 덩어리로 네트워크를 통해 이동한다. 패킷은 지정된 형식의 바이트 시퀀스로, 다른 장치는 다른 패킷 형식을 사용한다. 패킷의 일부에는 패킷이 어디서 오고 어디로 향하는지를 알려주는 주소정보가 들어있다. 패킷의 나머지 부분에는 길이 같은 패킷 자체에 대한 정보가 들어있고, 마지막으로는 전달하는 정보인 `페이로드(payload)`가 들어있다.
>
> 인터넷에서 데이터는 IP 패킷(IP packet, IP는 '인터넷 프로토콜'을 의미)으로 전달된다. IP 패킷은 모두 같은 형식으로 되어 있다. 특정 물리적 네트워크에서 IP 패킷은 하나 이상의 물리적 패킷으로 전송될 수 있다. 예를 들어, 가능한 한 가장 큰 이더넷 패킷(약 1500바이트)이 가능한 한 가장 큰 IP패킷(약 65000바이트)보다 훨씬 작기 때문에 큰 IP패킷은 여러개의 작은 이더넷 패킷으로 분할된다.
>
> 각 IP 패킷은 여러 개의 게이트웨이를 통과한다. 각 게이트웨이는 최종 수신지에 더 가까운 게이트웨이로 패킷을 보낸다. 패킷이 여기저기로 이동함에 따라, 여남은 개의 다른 회사나 기관이 소유하고 운영하며 다른 국가에 있을 확률이 꽤 높은 20개의 게이트웨이를 통과할 수도 있다. 트래픽은 최단 경로를 따를 필요가 없다. 편의성과 비용으로 인해 더 긴 경로를 통해 패킷을 라우팅할 가능성이 있다. 발신지와 수신지가 미국 이외 지역으로 되어 있는 많은 패킷이 미국을 통과하는 케이블을 사용하는데, 이 점을 이용하여 NSA가 전 세계의 트래픽을 기록한 것이다.
>
> (발췌)

### IP 주소의 할당

> 중앙 기관은 연속적인 IP 주소 블록을 네트워크 관리자에게 할당하고, 네트워크 관리자는 네트워크상의 호스트 컴퓨터들에 개별 주소를 할당한다. 따라서 각 호스트 컴퓨터에는 자신이 있는 네트워크에 따라 로컬로 할당된 고유한 주소가 있다. 이 주소는 데스크톱 컴퓨터에서는 영구적일 수 있지만, 모바일 장치의 경우 동적이며 적어도 장치가 인터넷에 다시 연결될 때마다 바뀐다.
>
> (발췌)

### IP와 TCP

IP는 Internet Protocol을 뜻한다.

> **인터넷 프로토콜**(**IP**, **I**nternet **P**rotocol, [문화어](https://ko.wikipedia.org/wiki/%EB%AC%B8%ED%99%94%EC%96%B4): 호상망규약)은 송신 [호스트](https://ko.wikipedia.org/wiki/%ED%98%B8%EC%8A%A4%ED%8A%B8)와 수신 호스트가 [패킷 교환 네트워크](https://ko.wikipedia.org/wiki/%ED%8C%A8%ED%82%B7_%EA%B5%90%ED%99%98_%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC)(패킷 스위칭 네트워크, Packet Switching Network)에서 정보를 주고받는 데 사용하는 정보 위주의 규약(프로토콜, Protocol)이며, OSI 네트워크 계층에서 호스트의 주소지정과 패킷 분할 및 조립 기능을 담당한다. 줄여서 **아이피**(IP)라고도 한다.
>
> IP의 정보는 [패킷](https://ko.wikipedia.org/wiki/%ED%8C%A8%ED%82%B7) 혹은 [데이터그램](https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B7%B8%EB%9E%A8)이라고 하는 덩어리로 나뉘어 전송된다. IP에서는 이전에 통신한 적 없는 호스트에 패킷을 보낼 때 경로 설정이 필요없다.
>
> IP는 비신뢰성(unreliability)과 비연결성(connectionlessness)이 특징이다. 비신뢰성은 흐름에 관여하지 않기 때문에 보낸 정보가 제대로 갔는지 보장하지 않는다는 뜻이다. 예를 들어 전송과정에서 패킷이 손상될 수도 있고, 같은 호스트에서 전송한 패킷의 순서가 뒤죽박죽이 될 수도 있고, 같은 패킷이 두 번 전송될 수도 있으며, 아예 패킷이 사라질 수도 있다. 패킷 전송과 정확한 순서를 보장하려면 [TCP](https://ko.wikipedia.org/wiki/%EC%A0%84%EC%86%A1_%EC%A0%9C%EC%96%B4_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C) 프로토콜과 같은 IP의 상위 프로토콜을 이용해야 한다.
>
> 현재 [인터넷](https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%EB%84%B7)에서 사용하는 표준 프로토콜은 인터넷 프로토콜의 4번째 판인 [IPv4](https://ko.wikipedia.org/wiki/IPv4)이다. 그러나 IPv4는 주소공간 고갈 문제를 겪고 있어 조만간 6번째 판인 [IPv6](https://ko.wikipedia.org/wiki/IPv6)가 대중화될 것으로 보인다. [마이크로소프트](https://ko.wikipedia.org/wiki/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%86%8C%ED%94%84%ED%8A%B8) [윈도 7](https://ko.wikipedia.org/wiki/%EC%9C%88%EB%8F%84_7), [OS X](https://ko.wikipedia.org/wiki/OS_X), [리눅스](https://ko.wikipedia.org/wiki/%EB%A6%AC%EB%88%85%EC%8A%A4) 등 현재 널리 쓰이고 있는 대부분의 [운영 체제](https://ko.wikipedia.org/wiki/%EC%9A%B4%EC%98%81_%EC%B2%B4%EC%A0%9C)는 IPv6 프로토콜을 지원한다.
>
> (위키백과 발췌)

인터넷 프로토콜 스위트

> **인터넷 프로토콜 스위트**([영어](https://ko.wikipedia.org/wiki/%EC%98%81%EC%96%B4): Internet Protocol Suite)는 [인터넷](https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%EB%84%B7)에서 [컴퓨터](https://ko.wikipedia.org/wiki/%EC%BB%B4%ED%93%A8%ED%84%B0)들이 서로 정보를 주고받는 데 쓰이는 통신규약([프로토콜](https://ko.wikipedia.org/wiki/%ED%86%B5%EC%8B%A0_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C))의 모음이다. 인터넷 프로토콜 스위트 중 [TCP](https://ko.wikipedia.org/wiki/%EC%A0%84%EC%86%A1_%EC%A0%9C%EC%96%B4_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C)와 [IP](https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%EB%84%B7_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C)가 가장 많이 쓰이기 때문에 **TCP/IP 프로토콜** 스위트라고도 불린다.
>
> [(위키백과 발췌)](https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%EB%84%B7_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C_%EC%8A%A4%EC%9C%84%ED%8A%B8)
>
> [OSI 모형 참조, 위키백과 발췌](https://ko.wikipedia.org/wiki/OSI_%EB%AA%A8%ED%98%95)

TCP

> IP 위에 있는 TCP(Transmission Control Protocol: 전송 제어 프로토콜)라는 프로토콜은 IP를 사용하여 발신지에서 수신지까지 임의 길이의 바이트 시퀀스를 전송하는 안정적인 메커니즘을 제공한다. TCP 위에서는 고수준의 프로토콜들이 웹 브라우징, 메일, 파일 공유 등 우리가 '인터넷' 이라고 생각하는 서비스를 제공하기 위해 TCP를 사용한다. 다른 프로토콜도 많이 있다. 예를 들어, 동적으로 IP 주소를 변경하는 것은 DHCP(동적 호스트 구성 프로토콜)라는 프로토콜에 의해 처리된다. 이 프로토콜들이 모두 합쳐져서 인터넷을 정의한다.
>
> (발췌)

> **전송 제어 프로토콜**(**T**ransmission **C**ontrol **P**rotocol, **TCP**, [문화어](https://ko.wikipedia.org/wiki/%EB%AC%B8%ED%99%94%EC%96%B4): 전송조종규약)은 [인터넷 프로토콜 스위트](https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%EB%84%B7_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C_%EC%8A%A4%EC%9C%84%ED%8A%B8)(IP)의 핵심 [프로토콜](https://ko.wikipedia.org/wiki/%ED%86%B5%EC%8B%A0_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C) 중 하나로, IP와 함께 *TCP/IP*라는 명칭으로도 널리 불린다. TCP는 [근거리 통신망](https://ko.wikipedia.org/wiki/%EA%B7%BC%EA%B1%B0%EB%A6%AC_%ED%86%B5%EC%8B%A0%EB%A7%9D)이나 [인트라넷](https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%8A%B8%EB%9D%BC%EB%84%B7), [인터넷](https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%EB%84%B7)에 연결된 컴퓨터에서 실행되는 프로그램 간에 일련의 [옥텟](https://ko.wikipedia.org/wiki/%EC%98%A5%ED%85%9F_(%EC%BB%B4%ED%93%A8%ED%8C%85))을 안정적으로, 순서대로, 에러없이 교환할 수 있게 한다. TCP는 [전송 계층](https://ko.wikipedia.org/wiki/%EC%A0%84%EC%86%A1_%EA%B3%84%EC%B8%B5)에 위치한다. 네트워크의 정보 전달을 통제하는 프로토콜이자 인터넷을 이루는 핵심 프로토콜의 하나로서 [국제 인터넷 표준화 기구](https://ko.wikipedia.org/wiki/%EA%B5%AD%EC%A0%9C_%EC%9D%B8%ED%84%B0%EB%84%B7_%ED%91%9C%EC%A4%80%ED%99%94_%EA%B8%B0%EA%B5%AC)(IETF)의 [RFC 793](https://ko.wikipedia.org/w/index.php?title=RFC_793&action=edit&redlink=1)에 기술되어 있다.
>
> TCP는 [웹 브라우저](https://ko.wikipedia.org/wiki/%EC%9B%B9_%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80)들이 [월드 와이드 웹](https://ko.wikipedia.org/wiki/%EC%9B%94%EB%93%9C_%EC%99%80%EC%9D%B4%EB%93%9C_%EC%9B%B9)에서 서버에 연결할 때 사용되며, [이메일](https://ko.wikipedia.org/wiki/%EC%9D%B4%EB%A9%94%EC%9D%BC) 전송이나 파일 전송에도 사용된다.
>
> TCP의 안정성을 필요로 하지 않는 애플리케이션의 경우 일반적으로 TCP 대신 [비접속형](https://ko.wikipedia.org/w/index.php?title=%EB%B9%84%EC%A0%91%EC%86%8D%ED%98%95_%ED%86%B5%EC%8B%A0&action=edit&redlink=1) [사용자 데이터그램 프로토콜](https://ko.wikipedia.org/wiki/%EC%82%AC%EC%9A%A9%EC%9E%90_%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B7%B8%EB%9E%A8_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C)(User Datagram Protocol)을 사용한다. 이것은 전달 확인 및 순차 보장 기능이 없는 대신 오버헤드가 작고 지연시간이 짧다는 장점이 있다.
>
> (위키백과 발췌)

TCP/IP 프로토콜

> 인터넷에는 많은 프로토콜이 있으며 그중 두 가지는 정말 필수적이다. IP는 인터넷 프로토콜(Internet Protocol)이다. IP는 개별 패킷의 형식을 지정하고 패킷을 전송하는 방법을 정의한다. TCP, 즉 전송 제어 프로토콜(Transmission Control Protocol)은 IP 패킷을 데이터 스트림으로 결합하고 서비스에 연결하느 방법을 정의 한다. 이 둘을 합쳐서 TCP/IP라고 한다.
>
> (발췌)

> IP 레벨 위에서는 TCP가 안정적인 통신을 제공하므로 사용자(실제로는 프로그래머)가 정보의 스트림에 불과한 패킷에 관해 생각할 필요가 없다. 우리가 '인터넷'이라고 생각하는 서비스의 대부분은 TCP를 사용한다.
>
> 이 프로토콜들 위에는 웹, 메일, 파일 전송 등의 서비스를 제공하는 애플리케이션 레벨 프로토콜들이 있고, 주로 TCP에 기반을 두고 구현된다. 따라서 여러 개의 프로토콜 계층이 있고, 각각은 아래에 있는 프로토콜 서비스에 의존하고 위에 있는 프로토콜에 서비스를 제공한다. 이것은 6장에서 설명한 소프트웨어의 계층화에 대한 매우 좋은 예다.
>
> UDP, 즉 사용자 데이터그램 프로토콜(User Datagram Protocol)은 TCP와 같은 레벨의 또 다른 프로토콜이다. UDP는 TCP보다 훨씬 간단하고 양방향 스트림을 필요로 하지 않는 데이터 교환에 사용되며, 몇 가지 추가 기능을 갖출 효율적인 패킷을 전달만 가능하다. DNS가 UDP를 사용하고, 비디오 스트리밍, VoIP, 일부 온라인 게임도 UDP를 사용한다.
>
> (발췌)

```
     [애플리케이션]
    [    TCP    ]
  [       IP       ]
[       물리 계층       ]
```

###  상위 레벨 프로토콜

> TCP는 두 대의 컴퓨터 간에 데이터를 주고받는 신뢰할 수 있는 양방향 스트림을 제공한다. 인터넷 서비스와 애플리케이션은 TCP를 전송 메커니즘으로 사용하지만, 필요한 기능에 특유한 자신만의 프로토콜을 가지고 있다. 예를 들어, HTTP, 즉 하이퍼텍스트 전송 프로토콜(HyperText Transfer Protocol)은 웹 브라우저와 서버에서 사용되는 특히 간단한 프로토콜이다. 링크를 클릭하면 브라우저가 서버(가령 amazon.com)의 포트 80에 TCP/IP연결을 열고 특정 페이지를 요청하는 짧은 메시지를 보낸다. 그림 9.6에서 브라우저는 왼쪽 상단의 클라이언트 애플리케이션이다. 메시지는 프로토콜 체인을 따라 내려가서 인터넷을 건너고(보통 후러씬 더 많은 단계를 거친다), 반대쪽 끝에서 상응하는 서버 애플리케이션까지 올라간다.

```
(클라이언트)                                                        (서버)
앱                                                                 앱
TCP             (게이트웨이)       (게이트웨이)  (게이트웨이)            TCP
IP                 IP                IP     ... IP                 IP
	-> 물리 계층 ->     -> 물리 계층 ->     ->         -> 물리 계층  ->
	  (예:전화)          (예:광섬유)                     (예:이더넷)

```

### 월드와이드 웹

> 인터넷에서 가장 눈에 띄는 부분은 월드 와이드 웹으로, 지금은 그냥 '웹'이라고 한다. 인터넷과 웹을 하나로 보는 경향이 있지만, 둘은 서로 다르다. 9장에서 보았듯이 인터넷은 전 세계 수백만 대의 컴퓨터가 서로 쉽게 통신할 수 있도록 해 주는 통신 인프라 또는 하위 계층이다. 웹은 정보를 제공하는 컴퓨터들(서버들)과 정보를 요청하는 컴퓨터들(클라이언트들)을 연결한다. 웹은 인터넷을 '사용하여'연결을 맺고 정보를 전달하며 인터넷에서 이용할 수 있는 다른 서비스에 접근하기 위한 인터페이스를 제공한다.
>
> 많은 훌륭한 아이디어와 마찬가지로, 웹은 본질적으로 간단하다. 어디나 연결되어 있고 효율적이며 개방적이고 기본적으로 무료인 기저 네트워크가 존재한다는 전제하에(매우 중요한 조건이다) 단지 네 가지만이 중요하다.
>
> 첫 번째는 URL, 즉 균일 자원 지시자(Uniform Resource Locator)로, http://www.amazon.com같이 정보 출처에 대한 이름을 명시한다.
>
> 둘째는 HTTP, 즉 하이퍼텍스트 전송 프로토콜(HyperText Transfer Protocol)로, 앞 장에서 상위 레벨 프로토콜의 예로 간략하게 언급한 것이다. HTTP는 간단하다. 클라이언트가 특정 URL을 요청하면 서버는 요청된 정보를 반환한다.
>
> 셋째는 HTML, 즉 하이퍼텍스트 마크업 언어(HyperText Markup Language)로, 서버가 반환하는 정보의 서식이나 표현 방식을 설명하기 위한 언어다. 이것도 마찬가지로 간단하고 매우 조금만 알아도 기본적인 사용법을 익힐 수 있다.
>
> 마지막으로, 브라우저가 있는데, 컴퓨터에서 실행되는 크롬, 파이어폭스, 사파리, 인터넷 익스플로러 같은 프로그램으로, URL과 HTTP를 사용하여 서버에 요청을 보내고 서버에서 보낸 HTML을 가져와서 표시해 준다.
>
> (발췌)

### 암호기법에서의 키(key)

> 암호 기법의 기본 아이디어는 앨리스와 밥이 내용은 비공개로 유지하되 서로 통신중이라는 점은 숨기지 않으면서 메시지를 주고받기를 원한다는 것이다. 이렇게 하려면 다른 사람은 이해할 수 없고 앨리스와 밥만 이해할 수 있도록 메시지를 변형했다가 다시 복원하는 데 사용할 수 있는 일종의 공유된 비밀이 있어야 한다. 이 비밀을 `키(key)`라고 한다. 예를 들어, 카이사르 암호에서 키는 알파벳이 옮겨지는 거리, 즉 A를 D로 바꾸기 위한 3 등의 값이 된다. 에그니마 같은 복잡한 기계식 암호화 장치에서 키는 여러 개의 코드 휠 설정과 한 조의 플러그배선 연결을 조합한 것이다. 최신 컴퓨터 기반 암호화 체계에서 키는 어떤 알고리즘에 사용되는 큰 비밀 수로, 이 알고리즘은 그 비밀 수를 모르고는 메시지를 복원하기가 실행 불가능한 방식으로 메시지의 비트를 변형시킨다.
>
> (발췌)

### 비밀 키 암호 기법

> 근본적으로 다른 두 종류의 암호 체계가 오늘날 사용되고 있다. 더 오래된 방식은 보통 `비밀 키 암호 기법` 또는 `대칭 키 암호 기법`이라고 한다. 암호화 및 복호화에 같은 키를 사용하므로 '대칭 키'가 특징을 더 잘 묘사해 주지만. '비밀 키'는 새로운 종류의 암호 체계의 이름인 `공개 키 암호 기법`과 더 잘 대비 되는데, 이는 다음 절에서 다룬다.
>
> 비밀 키 암호 기법에서는 같은 비밀 키를 사용하여 메시지를 암호화하고 복호화 한다. 이 비밀 키는 메시지를 교환하고자 하는 모든 당사자에 의해 공유된다. 알고리즘이 완전히 이해되고 결함이나 약점이 없다고 가정하면, 메시지 암호를 해독하는 유일한 방법은 무차별 대입 공격이다. 이 방법은 가능한 모든 비밀 키를 시도해서 암호화에 사용된 키를 찾는다. 이것은 오랜 시간이 걸릴 수 있다. 만약 키가 N비트라면 키를 찾는 데 드는 노력은 대략 2의 n승에 비례한다. 하지만 무차별 대입이 멍청한 것을 의미하지는 않는다. 공격자는 긴 키보다 짧은 키를 먼저 시도하고 가능성이 작은 것보다 그럴듯한 키를 먼저 시도할 것이다. 예를 들면, 'password'와 '12345'같이 흔한 단어나 숫자 패턴을 기반으로 하는 사전공격을 시도한다. 사람들이 키를 고르는 데 성의가 없거나 부주의할 경우 이러한 공격은 매우 성공적 일 수 있다.
>
> (발췌)

### DES와 AES

> 1976년경부터 2000년대 초반까지 가장 널리 사용된 비밀 키 암호 알고리즘은 IBM과 NSA가 개발한 데이터 암호화 표준(Data Encryption Standard), 즉 DES였다. DES는 56비트 키를 이용했는데, 컴퓨터가 빨라짐에 따라 56비트는 너무 짧다는 것이 판명됬다. 이로 인해 더 긴 키를 이용하는 새로운 알고리즘들을 만들게 됬다.
>
> 이들 중 가장 널리 사용되는 것은 고급 암호화 표준(Advanced Encryption Standard), 즉 AES다. AES는 128비트, 192비트, 256비트의 세 가지 키 길이를 지원하므로 수많은 가능한 키가 있으며, 어떤 약점이 발견되지 않는 한 수년 동안 무차별 대입 공격이 통하지 않을 것이다.
>
> (발췌 요약)

### 공개 키 암호 기법

>공개 키 암호 체계에서 각 사람은 공개 키와 개인 키로 구성된 키 쌍을 가지고 있다. 쌍으로 된 키들은 수학적으로 연관성이 있는 정수이며, 쌍 중의 하나의 키로 암호화된 메시지는 나머지 키로만 해독될 수 있으며 그 반대도 마찬가지인 속성을 지니고 있다. 키가 충분히 길다면 공격자가 비밀 메시지를 해독하거나 공개 키에서 개인 키를 추론하는 것은 실행 불가능하다. 공격자가 사용할 수 있는 가장 잘 알려진 알고리즘은 키 길이에 따라 기하급수적으로 증가하는 실행 시간을 필요로 한다.
>
>실제로 사용될 때, 공개 키는 정말로 공개된다. 흔히 웹 페이지에 게시되어 모든 사람이 이용할 수 있다. 개인 키는 엄격히 비공개로 유지되며, 이 키 쌍의 소유자에게만 알려져 있는 비밀로 유지되어야 한다.
>
>엘리스가 밥에게 밥만 읽을 수 있도록 암호화된 메시지를 보내고 싶다고 가정해 보자. 앨리스는 밥의 웹페이지로 가서 그의 공개 키를 가져오고 그에게 보낼 자신의 메시지를 암호화하는데 사용한다. 그녀가 암호화된 메시지를 보내면 도청자 이브는 앨리스가 밥에게 메시지를 보낸다는 것을 알 수 있을지 모르지만, 메시지가 암호화되어 있어서 그 내용은 알 수 없다.
>
>밥은 자신의 개인 키로 앨리스의 메시지를 해독하는데, 이는 그만이 알고 있는 정보이자 자신의 공개 키로 암호화된 메시지를 해독하는 유일한 방법이다. 밥이 앨리스에게 암호화된 답신을 보내고자 한다면 '앨리스의' 공개 키로 암호화한다. 마찬가지로 이브는 답신을 볼 수는 있지만, 이해할 수 없는 암호화된 형태로만 볼 수 있다. 앨리스는 그녀만 알고 있는 자신의 개인 키로 밥의 답신을 해독한다.
>
>이러한 책략은 키 분배 문제를 해결해 주는데, 분배해야 할 공유된 비밀이 없기 때문이다. 앨리스와 밥은 자신들의 웹 페이지에 각자의 공개 키를 가지고 있으며, 누구나 사전 협의나 아무런 비밀 교환 없이 둘 중 누구와도 비공개 대화를 계속할 수 있다.
>
>공개 키 암호의 기법의 한 가지 결점은 알고리즘이 더 느린 경향이 있다는 것인데, 어쩌면 AES같은 비밀 키 알고리즘보다 몇백배에서 몇천 배 더 느릴 수 있다. 따라서 모든 것을 공개 키로 암호화하는 대신 2단계 절차를 이용한다. 공개 키를 사용하여 임시 비밀 키에 대해 합의를 본 다음 AES를 사용하여 대량으로 데이터를 전송한다.
>
>통신은 각 단계에서 보안이 유지되는데, 처음에는 임시 키를 설정하기 위해 공개 키를 사용하고, 다음으로 대량의 데이터 교환을 위해 AES를 사용하기 때문에 안전하다. 인터넷 상점, 온라인 메일 서비스 및 다른 여러 사이트를 방문하는 경우 여러분은 이 기법을 사용하고 있는 것 이다. 실제로 작동하는 것을 확인할 수 있는데, 이러한 경우 브라우저에서 HTTPS 프로토콜로 연결하고 있다는 것을 보여 주고 링크가 암호화되었음을 나타내는 닫힌 자물쇠 아이콘을 표시해 주기 때문이다.
