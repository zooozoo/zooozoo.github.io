---
category: record
---
# **SQL 기본 문법**

### SQL이란 무엇인가?
* SQL은 구조화 된 쿼리 언어
* SQL을 사용하면 데이터베이스에 액세스하고 조작 할 수 있습니다.
* SQL은 ANSI (American National Standards Institute) 표준입니다.

### 웹사이트에서 SQL 사용
데이터베이스의 데이터를 보여주는 웹 사이트를 구축하려면 다음이 필요합니다.
* RDBMS 데이터베이스 프로그램 (예 : MS Access, SQL Server, MySQL)
* PHP 또는 ASP와 같은 서버 측 스크립팅 언어가 필요합니다.
* SQL을 사용하여 원하는 데이터를 얻을 수 있습니다.
* HTML / CSS를 사용하여 페이지의 스타일을 지정합니다.

### RDBMS란?
* RDBMS는 관계형 데이터베이스 관리 시스템의 약자입니다.
* RDBMS는 SQL과 MS SQL Server, IBM DB2, Oracle, MySQL 및 Microsoft Access와 같은 모든 최신 데이터베이스 시스템의 기초입니다.
* RDBMS의 데이터는 테이블이라는 데이터베이스 오브젝트에 저장됩니다. 테이블은 관련 데이터 항목의 모음이며 열과 행으로 구성됩니다.
* 모든 테이블은 필드라는 더 작은 엔티티로 나뉩니다. Customers 테이블의 필드는 CustomerID, CustomerName, ContactName, Address, City, PostalCode 및 Country로 구성됩니다. **필드는 테이블의 모든 레코드에 대한 특정 정보를 유지 관리하도록 설계된 테이블의 열입니다.**
* 레코드(행) :  레코드는 테이블에있는 개별 항목입니다. 예를 들어, 위의 Customers 테이블에는 91 개의 레코드가 있습니다. 레코드는 테이블의 가로 엔티티입니다.
* 컬럼(열) : 컬럼은 테이블의 특정 필드와 연관된 모든 정보를 포함하는 테이블의 수직 엔티티입니다.

### SQL문 기본 문법
* SQL 키워드는 대소 문자를 구분하지 않습니다. select는 SELECT와 같습니다.
* 일부 데이터베이스 시스템에서는 각 SQL 문의 끝에 세미콜론이 필요합니다. 세미콜론은 데이터베이스 시스템에서 각 SQL 문을 분리하여 서버에 대한 동일한 호출에서 둘 이상의 SQL 문을 실행할 수 있도록하는 표준 방법입니다.

### 주요 핵심 SQL명령어
```
SELECT - 데이터베이스에서 데이터를 추출합니다.
UPDATE - 데이터베이스의 데이터를 업데이트합니다.
DELETE - 데이터베이스에서 데이터를 삭제합니다.
INSERT INTO - 새로운 데이터를 데이터베이스에 삽입합니다.
CREATE DATABASE - 새 데이터베이스를 만듭니다.
ALTER DATABASE - 데이터베이스를 수정합니다.
CREATE TABLE - 새 테이블을 만듭니다.
ALTER TABLE - 테이블을 수정합니다.
DROP TABLE - 테이블을 삭제합니다.
CREATE INDEX - 색인 (검색 키)을 작성합니다.
DROP INDEX - 색인을 삭제합니다.
```

### SQL SELECT문
* SELECT 문은 데이터베이스에서 데이터를 선택하는 데 사용됩니다.리턴 된 데이터는 결과 세트라고하는 결과 테이블에 저장됩니다.

* SELECT문 사용법
```
SELECT 필드이름, 필드이름, ... FROM  테이블 이름
```

* 전체 필드 선택
```
SELECT * FROM table_name;
```

### SQL SELECT DISTINCT문
* SELECT DISTINCT는 고유 한 (다른) 값만 리턴하는 데 사용됩니다. 테이블 내에서 열은 종종 많은 중복 값을 포함합니다. 때로는 서로 다른 (뚜렷한) 값만 나열하려고합니다. SELECT DISTINCT.은 고유 한 (다른) 값만 리턴하는 데 사용됩니다. (중복값 제거하고 고유한 값들만 얻어내는 명령문)

* 기본 사용법
```
SELECT DISTINCT 필드이름, 필드이름, ... FROM 테이블이름
```

* 다음은 해당 필드의 고유한 레코드 값의 수를 나열한다.
```
SELECT COUNT(DISTINCT 필드이름) FROM 테이블이름;
```

### SQL WHERE절

* WHERE 절은 레코드를 필터링하는 데 사용됩니다. WHERE 절은 지정된 조건을 충족하는 레코드 만 추출하는 데 사용됩니다.

* 기본 사용법
```
SELECT 필드이름, 필드이름, ... FROM 테이블이름
WHERE 조건;
```

* 사용예시1 : Customers 테이블에서 Mexico 국가의 모든 고객을 선택
```
SELECT * FROM Customers
WHERE country='Mexico';
```

* SQL은 텍스트 값에 대해 작은 따옴표를 사용해야합니다 (대부분의 데이터베이스 시스템은 큰 따옴표도 허용합니다). 그러나 숫자 필드는 따옴표로 묶지 않아야합니다. 다음 사용예시는 전체 필드중에서 CustomersID값이 1인 값을 가져옵니다.
```
SELECT * FROM Customers
WHERE CustomerID=1;
```

* WHERE 절에 있는 연산자

Operator	|	Description
--- | ---
=	|	Equal
<>	|	Not equal. Note: In some versions of SQL this operator may be written as !=
>	|	Greater than
<	|	Less than
>=	|	Greater than or equal
<=	|	Less than or equal
BETWEEN	|	Between an inclusive range
LIKE	|	Search for a pattern
IN	|	To specify multiple possible values for a column


### SQL AND, OR 및 NOT 연산자

* WHERE 절은 AND, OR 및 NOT 연산자와 결합 할 수 있습니다. AND 및 OR 연산자는 둘 이상의 조건에 따라 레코드를 필터링하는 데 사용됩니다.
```
AND로 구분 된 모든 조건이 TRUE이면 AND 연산자는 레코드를 표시합니다.
OR로 구분 된 조건이 TRUE 인 경우 OR 연산자는 레코드를 표시합니다.
NOT 연산자는 조건이 참이 아닌 경우 레코드를 표시합니다.
```

* 기본 사용법
```
SELECT 필드이름, 필드이름, ...
FROM 테이블이름
WHERE 조건 AND 조건 AND 조건...;
```
```
SELECT 필드이름, 필드이름, ...
FROM 테이블이름
WHERE 조건 OR 조건 OR 조건...;
```
```
SELECT 필드이름, 필드이름, ...
FROM 테이블이름
WHERE NOT 조건...;
```

* AND, OR 및 NOT 결합
AND, OR 및 NOT 연산자를 결합 할 수도 있습니다.다음 SQL 문은 country가 "Germany"이고 도시가 "Berlin"또는 "München"(복잡한 표현식을 형성하기 위해 괄호를 사용해야 함) 인 "Customers"의 모든 필드를 선택합니다.
```
SELECT * FROM Customers
WHERE Country='Germany' AND (City='Berlin' OR City='München');
```

* 다음 SQL 문은 country가 "Germany"가 아니며 "USA"가 아닌 "Customers"의 모든 필드를 선택합니다.
```
SELECT * FROM Customers
WHERE NOT Country='Germany' AND NOT Country='USA';
```

### SQL ORDER BY 키워드
* ORDER BY 키워드는 결과 집합을 오름차순 또는 내림차순으로 정렬하는 데 사용됩니다. ORDER BY 키워드는 기본적으로 레코드를 오름차순으로 정렬합니다. 내림차순으로 레코드를 정렬하려면 DESC 키워드를 사용하십시오.

* 기본 사용법
```
SELECT 필드이름, 필드이름, ...
FROM 테이블이름
ORDER BY 필드이름, 필드이름, ... ASC|DESC;
```

* 다음 SQL 문은 "고객"테이블의 모든 고객을 "국가"열로 정렬하여 선택합니다.
```
SELECT * FROM Customers
ORDER BY Country;
```

* 다음 SQL 문은 "고객"테이블의 모든 고객을 "국가"열로 역순으로 정렬하여 선택합니다.
```
SELECT * FROM Customers
ORDER BY country DESC;
```

* 다음 SQL 문은 "Customers"테이블의 모든 고객을 "Country"및 "CustomerName"열로 정렬하여 선택합니다. (Country로 정렬한 다음 CustomerName으로 다시 정렬)
```
SELECT * FROM Customers
ORDER BY Country, CustomerName;
```

* 다음 SQL 문은 "Customers"테이블의 모든 고객을 "Country"로 오름차순으로 정렬하고 "CustomerName"열로 내림차순으로 정렬합니다. (Country로 오름차순 정렬후 CustomerName으로 다시 내림차순으로 정렬)
```
SELECT * FROM Customers
ORDER BY Country ASC, CustomerName DESC;
```

### SQL INSERT INTO문

* INSERT INTO 문은 테이블에 새 레코드를 삽입하는 데 사용됩니다.

* INSERT INTO 문을 작성하는 첫 번째 방법 : 삽입 할 열 이름과 값을 모두 지정합니다.
```
INSERT INTO table_name (column1, column2, column3, ...)
VALUES (value1, value2, value3, ...);
```

* 표의 모든 열에 값을 추가하는 경우 SQL 조회에서 열 이름을 지정할 필요가 없습니다. 그러나 값의 순서가 테이블의 열과 동일한 순서인지 확인하십시오. INSERT INTO 구문은 다음과 같습니다.
```
INSERT INTO table_name
VALUES (value1, value2, value3, ...);
```

* 다음 SQL 문은 새 레코드를 삽입하지만 "CustomerName", "City"및 "Country"열에 만 데이터를 삽입합니다 (CustomerID는 자동으로 업데이트됩니다).
```
INSERT INTO Customers (CustomerName, City, Country)
VALUES ('Cardinal', 'Stavanger', 'Norway');
```

### SQL NULL 값

* NULL값이란? : NULL 값이있는 필드는 값이없는 필드입니다. 테이블의 필드가 선택적이면이 필드에 값을 추가하지 않고 새 레코드를 삽입하거나 레코드를 업데이트 할 수 있습니다. 그런 다음 필드는 NULL 값으로 저장됩니다.

* [NULL값에 대하여 잘 설명되어 있는 참고할만한 블로그](http://slowalk.tistory.com/2181)

* NULL값이 0 이나 혹은 공백으로 되어있는 필드와는 다르다는 것을 이해하는 것이 중요합니다. 널 값이 있는 필드는 레코드가 생성되는 동안 빈공간으로 남겨져 있다는 것을 말합니다.

* `IS NULL` 연산자와 `IS NOT NULL` 연산자를 통해 NULL 값을 테스트 할 수 있습니다.

* 다음 SQL.은 IS NULL 연산자를 사용하여 주소가없는 모든 값을 나열합니다.
```
SELECT LastName, FirstName, Address FROM Persons
WHERE Address IS NULL;
```

* 다음 SQL 문은 IS NOT NULL 연산자를 사용하여 주소가있는 모든 사람을 나열합니다.
 ```
SELECT LastName, FirstName, Address FROM Persons
WHERE Address IS NOT NULL;
```

### SQL UPDATE문

* UPDATE 문은 테이블의 기존 레코드를 수정하는 데 사용됩니다.

* 기본 사용법
```
UPDATE table_name
SET column1 = value1, column2 = value2, ...
WHERE condition;
```

* 테이블의 레코드를 업데이트 할 때에는 UPDATE 문에서 WHERE 절을 확인하십시오. WHERE 절은 갱신해야하는 레코드를 지정합니다. WHERE 절을 생략하면 테이블의 모든 레코드가 업데이트됩니다!
```
UPDATE Customers
SET ContactName='Juan';
```

* 한번에 여러 레코드를 업데이트 할 수도 있습니다. 업데이트 될 레코드 수를 결정하는 것은 WHERE 절입니다.
다음 SQL 문은 country가 "Mexico"인 모든 레코드에 대해 연락처 이름을 "Juan"으로 업데이트합니다.
```
UPDATE Customers
SET ContactName='Juan'
WHERE Country='Mexico';
```

### SQL DELETE문

* DELETE 문은 테이블의 기존 레코드를 삭제하는 데 사용됩니다.

* 기본 사용법
```
DELETE FROM table_name
WHERE condition;
```

* 다음 SQL문은 : Customers; 테이블에서 고객 "Alfreds Futterkiste"를 제거합니다.
```
DELETE FROM Customers
WHERE CustomerName='Alfreds Futterkiste';
```

* 아래의 명령을 통해, 테이블을 제거하지 않고 테이블의 모든 행을 제거 할 수 있습니다. 이것은 테이블 구조, 속성 및 인덱스가 손상되지 않는다는 것을 의미합니다.
`DELETE FROM table_name;` 또는 `DELETE * FROM table_name;`

### SQL TOP, LIMIT 또는 ROWNUM절
* SELECT TOP 절은 리턴 할 레코드 수를 지정하는 데 사용됩니다. SELECT TOP 절은 수천 개의 레코드가있는 큰 테이블에서 유용합니다. 많은 수의 레코드를 반환하면 성능에 영향을 줄 수 있습니다.
주의할 점은 모든 데이터베이스 시스템이 SELECT TOP 절을 지원하는 것은 아니라는 것 입니다. MySQL은 제한된 수의 레코드를 선택하기 위해 LIMIT 절을 지원하고 Oracle은 ROWNUM을 사용합니다.

* 기본 사용법

* SQL Server / MS 액세스 구문 :
```
SELECT TOP number|percent column_name(s)
FROM table_name
WHERE condition;
```
```
SELECT column_name(s)
FROM table_name
WHERE condition
LIMIT number;
```
```
SELECT column_name(s)
FROM table_name
WHERE ROWNUM <= number;
```

* 다음 SQL 문은 "Customers"테이블에서 처음 세 개의 레코드를 선택합니다.
```
SELECT TOP 3 * FROM Customers;
```

* 다음 SQL 문은 LIMIT 절을 사용하는 동일한 예제를 보여줍니다.
```
SELECT * FROM Customers
LIMIT 3;
```

* 다음 SQL 문은 ROWNUM을 사용하는 동일한 예제를 보여줍니다.
```
SELECT * FROM Customers
WHERE ROWNUM <= 3;
```

* 다음 SQL 문은 국가가 "Germany"인 "Customers"테이블에서 처음 세 개의 레코드를 선택합니다.
```
SELECT TOP 3 * FROM Customers
WHERE Country='Germany';
```

* 다음 SQL 문은 LIMIT 절을 사용하는 동일한 예제를 보여줍니다.
```
SELECT * FROM Customers
WHERE Country='Germany'
LIMIT 3;
```

* 다음 SQL 문은 ROWNUM을 사용하는 동일한 예제를 보여줍니다.
```
SELECT * FROM Customers
WHERE Country='Germany' AND ROWNUM <= 3;
```

### SQL MIN() 및 MAX()합수

* MIN () 함수는 선택된 컬럼의 가장 작은 값을 리턴합니다.
```
SELECT MIN(column_name)
FROM table_name
WHERE condition;
```

* MAX () 함수는 선택된 컬럼의의 가장 큰 값을 반환합니다.
```
SELECT MAX(column_name)
FROM table_name
WHERE condition;
```

* 다음 SQL 문은 가장 저렴한 제품의 가격을 찾습니다.
```
SELECT MIN(Price) AS SmallestPrice
FROM Products;
```

* 다음 SQL 문은 가장 비싼 제품의 가격을 찾습니다.
```
SELECT MAX(Price) AS LargestPrice
FROM Products;
```

### SQL COUNT(), AVG()및 SUM() 함수

* COUNT () 함수는 지정된 기준과 일치하는 행 수를 반환합니다.
```
SELECT COUNT(column_name)
FROM table_name
WHERE condition;
```

* AVG () 함수는 숫자 열의 평균값을 반환합니다.
```
SELECT AVG(column_name)
FROM table_name
WHERE condition;
```

* SUM () 함수는 숫자 열의 총 합계를 반환합니다.
```
SELECT SUM(column_name)
FROM table_name
WHERE condition;
```

### SQL LIKE연산자

* LIKE 연산자는 WHERE 절에서 열의 지정된 패턴을 검색하는 데 사용됩니다. LIKE 연산자와 함께 사용되는 두 개의 와일드 카드가 있습니다. (MS Access는 밑줄 `_` 대신 물음표 `?`를 사용합니다.)

> `%`백분율 기호는 0, 1 또는 복수 문자를 나타냅니다.

> `_`밑줄은 한 문자를 나타냅니다.

* 기본 사용법
```
SELECT column1, column2, ...
FROM table_name
WHERE columnN LIKE pattern;
```
AND 또는 OR 연산자를 사용하여 여러 조건을 결합 할 수도 있습니다.

* 몇가지 예시

LIKE Operator	|	Description
---- | ----
WHERE CustomerName LIKE `a%`	|	Finds any values that starts with "a"
WHERE CustomerName LIKE `%a`	|	Finds any values that ends with "a"
WHERE CustomerName LIKE `%or%`	|	Finds any values that have "or" in any position
WHERE CustomerName LIKE `_r%`	|	Finds any values that have "r" in the second position
WHERE CustomerName LIKE `a_%_%`	|	Finds any values that starts with "a" and are at least 3 characters in length
WHERE ContactName LIKE `a%o`	|	Finds any values that starts with "a" and ends with "o"

### SQL 와일드 카드 문자
* 와일드 카드 문자는 문자열의 다른 문자를 대체하는 데 사용됩니다. 와일드 카드 문자는 SQL LIKE 연산자 와 함께 사용됩니다 . LIKE 연산자는 WHERE 절에서 열의 지정된 패턴을 검색하는 데 사용됩니다.

* LIKE 연산자와 함께 사용되는 두 개의 와일드 카드가 있습니다. (MS Access는 밑줄 `_` 대신 물음표 `?`를 사용합니다.)
> `%` 백분율 기호는 0, 1 또는 복수 문자를 나타냅니다.

> `_` 밑줄은 한 문자를 나타냅니다.

* 다음 SQL 문은 City가 "ber"로 시작하는 모든 고객을 선택합니다.
```
SELECT * FROM Customers
WHERE City LIKE 'ber%';
```

### SQL IN 연산자
* IN 연산자를 사용하여 WHERE 절에 여러 값을 지정할 수 있습니다. IN 연산자는 여러 OR 조건의 줄임말입니다.

* 기본 사용법
```
SELECT column_name(s)
FROM table_name
WHERE column_name IN (value1, value2, ...);
```
또는
```
SELECT column_name(s)
FROM table_name
WHERE column_name IN (SELECT STATEMENT);
```

* 다음 SQL 문은 "Germany", "France"및 "UK"에있는 모든 고객을 선택합니다.
```
SELECT * FROM Customers
WHERE Country IN ('Germany', 'France', 'UK');
```
* 다음 SQL 문은 "Germany", "France"또는 "UK"에 있지 않은 모든 고객을 선택합니다.
```
SELECT * FROM Customers
WHERE Country NOT IN ('Germany', 'France', 'UK');
```
* 다음 SQL 문은 공급 업체와 동일한 국가의 모든 고객을 선택합니다.
```
ELECT * FROM Customers
WHERE Country IN (SELECT Country FROM Suppliers);
```

### SQL BETWEEN연산자
* BETWEEN 연산자는 주어진 범위 내의 값을 선택합니다. 값은 숫자, 텍스트 또는 날짜 일 수 있습니다. BETWEEN 연산자는 시작과 끝 값이 포함됩니다.

* 기본 사용법
```
SELECT column_name(s)
FROM table_name
WHERE column_name BETWEEN value1 AND value2;
```

* 다음 SQL 문은 가격이 10과 20 사이 인 모든 제품을 선택합니다.
```
SELECT * FROM Products
WHERE Price BETWEEN 10 AND 20;
```

* 다음 SQL 문은 가격이 10과 20 사이 인 모든 제품을 선택합니다. CategoryID가 1,2 또는 3 인 제품을 표시하지 않습니다.
```
SELECT * FROM Products
WHERE (Price BETWEEN 10 AND 20)
AND NOT CategoryID IN (1,2,3);
```

* 다음 SQL.은 'Carnarvon Tigers'와 'Mozzarella di Giovanni'사이에 ProductName이있는 모든 제품을 선택합니다.
```
SELECT * FROM Products
WHERE ProductName BETWEEN 'Carnarvon Tigers' AND 'Mozzarella di Giovanni'
ORDER BY ProductName;
```

* 다음 SQL 문은 ProductName이 'Carnarvon Tigers'및 'Mozzarella di Giovanni'가 아닌 모든 제품을 선택합니다.
```
SELECT * FROM Products
WHERE ProductName NOT BETWEEN 'Carnarvon Tigers' AND 'Mozzarella di Giovanni'
ORDER BY ProductName;
```

* 다음 SQL 문은 OrderDate BETWEEN '04 -July-1996 '및 '09-Junly-1996'이있는 모든 주문을 선택합니다.
```
SELECT * FROM Orders
WHERE OrderDate BETWEEN #07/04/1996# AND #07/09/1996#;
```

### SQL Aliases
* SQL (Aliases)별칭은 테이블 또는 테이블의 열에 임시 이름을 지정하는 데 사용됩니다. 앨리어스는 종종 컬럼 이름을 읽기 쉽게하기 위해 사용됩니다. 별명은 조회 기간 동안 만 존재합니다.

* 컬럼 Aliase 지정예시
```
SELECT column_name AS alias_name
FROM table_name;
```

* 테이블 Aliase 지정예시
```
SELECT column_name(s)
FROM table_name AS alias_name;
```

* 다음 SQL 문은 CustomerID 열과 CustomerName 열의 두 가지 별칭을 만듭니다.
```
SELECT CustomerID as ID, CustomerName AS Customer
FROM Customers;
```

* 다음 SQL 문은 CustomerName 열과 ContactName 열의 두 가지 별칭을 만듭니다. 참고 : 별칭 이름에 공백이 포함되어 있으면 큰 따옴표 또는 대괄호가 필요합니다.
```
SELECT CustomerName AS Customer, ContactName AS [Contact Person]
FROM Customers;
```

* 다음 SQL 문은 네 개의 열 (Address, PostalCode, City 및 Country)을 결합하는 "Address"라는 별칭을 만듭니다. (각 필드의 결합의 경우 결합될 양식을 ',' 이나 ' ' 과 같이 만들어 줄 수 있다.)
```
SELECT CustomerName, Address + ', ' + PostalCode + ' ' + City + ', ' + Country AS Address
FROM Customers;
```

* 참고 : 위의 SQL 문을 MySQL에서 작동 시키려면 다음을 사용하십시오.
```
SELECT CustomerName, CONCAT(Address,', ',PostalCode,', ',City,', ',Country) AS Address
FROM Customers;
```

* 다음 SQL.은 CustomerID = 4 (Around the Horn) 인 고객의 모든 주.을 선택합니다. "Customers"및 "Orders"테이블을 사용하고 각각 "c"및 "o"테이블 별칭을 부여합니다 (여기서 별칭을 사용하여 SQL을 더 짧게 만듭니다).
```
SELECT o.OrderID, o.OrderDate, c.CustomerName
FROM Customers AS c, Orders AS o
WHERE c.CustomerName="Around the Horn" AND c.CustomerID=o.CustomerID;
```

* Aliase는 다음과 같은 경우에 유용합니다.
```
쿼리에 두 개 이상의 테이블이 관련되어 있습니다.
함수는 쿼리에서 사용됩니다.
열 이름이 크거나 매우 읽을 수 없습니다.
두 개 이상의 열이 결합되었습니다.
```

### JOIN
* JOIN 절은 두 개 이상의 테이블에있는 행을 결합하는 데 사용됩니다.
* 수학의 집합 처럼 조건을 두고 그 조건 안에서 원하는 자료를 선택하는 것

* 기본 사용법

Oders

OrderID	|	CustomerID	|	OrderDate
---|---|---
10308	|	2	|	1996-09-18
10309	|	37	|	1996-09-19
10310	|	77	|	1996-09-20

Customers

CustomerID	|	CustomerName	|	ContactName	|	Country
---|---|---|---
1	|	Alfreds Futterkiste	|	Maria Anders	|	Germany
2	|	Ana Trujillo Emparedados y helados	|	Ana Trujillo	|	Mexico
3	|	Antonio Moreno Taquería	|	Antonio Moreno	|	Mexico

Orders테이블의 CustomerID열은 Customers테이블의 CustomerID를 나타냅니다. 위의 두 테이블 사이의 공유하고 있는 정보는 CustomerID열 입니다. 이와같이 같은 정보를 통하여 위의 두 테이블의 공통된 Value를 가지는 레코드를 골라내는 SQL문장을 만들어 낼 수 있습니다.
```
SELECT Orders.OrderID, Customers.CustomerName, Orders.OrderDate
FROM Orders
INNER JOIN Customers ON Orders.CustomerID=Customers.CustomerID;
```
INNER JOIN문에서 Orders의 CustomersID와 Customers의 CustomersID가 같은 값을 찾아내고 같은 값을 가지는 행의 정보를 두 테이블에서 가져와 SELECT문에서 산출한다.

* 다양한 유형의 SQL JOIN
```
(INNER) JOIN : 두 테이블에서 값이 일치하는 레코드를 반환합니다.
LEFT (OUTER) JOIN : 왼쪽 테이블에서 모든 레코드를 반환하고 오른쪽 테이블에서 일치하는 레코드를 반환합니다.
RIGHT (OUTER) JOIN : 오른쪽 테이블에서 모든 레코드를 반환하고 왼쪽 테이블에서 일치하는 레코드를 반환합니다.
FULL (OUTER) JOIN : 왼쪽 또는 오른쪽 테이블에 일치하는 항목이 있으면 모든 레코드를 반환합니다.
```
![벤다이어그램](./img_join.gif)
![벤다이어그램](./img_leftjoin.gif)
![벤다이어그램](./img_rightjoin.gif)
![벤다이어그램](./img_fulljoin.gif)

### SQL INNER JOIN 키워드
* INNER JOIN 키워드는 두 표에서 모두 일치하는 값을 가진 레코드를 선택합니다.

* 기본 사용법
```
SELECT column_name(s)
FROM table1
INNER JOIN table2 ON table1.column_name = table2.column_name;
```
다음과 같이 놓고 보면 좀더 이해하기 쉽다.
```
SELECT column_name(s)
FROM table1 INNER JOIN table2 ON table1.column_name = table2.column_name;
```
해당 컬럼은 FROM table1 과 table2 의 colum_name INNER JOIN한 데이터를 기준으로 해서 자료를 가져온다.

* INNER JOIN 키워드는 비교대상인 컬럼간에 일치하는 모든 행을 선택합니다. '주문 테이블의 비교대상컬럼과 '고객'테이블의 비교대상컬럼에 일치하는 레코드가 없을경우 아무런 레코드도 표시되지 않습니다.

* 다음 SQL문은 Customers정보와 Shippers정보가 있는 Orders 테이블을 선택합니다.
```
SELECT Orders.OrderID, Customers.CustomerName, Shippers.ShipperName
FROM ((Orders
INNER JOIN Customers ON Orders.CustomerID = Customers.CustomerID)
INNER JOIN Shippers ON Orders.ShipperID = Shippers.ShipperID);
```

### SQL LEFT JOIN키워드
* LEFT JOIN키워드는 왼쪽 테이블의 모든 레코드와 오른쪽테이블의 일치 레코들을 반환합니다. 일치하는 것이 없으면 오른쪽 테이블의 정보는 모두 Null값이 됩니다.

* 기본 사용법
```
SELECT column_name(s)
FROM table1
LEFT JOIN table2 ON table1.column_name = table2.column_name;
```

* 일부 데이터베이스에서는 LEFT JOIN을 LEFT OUTER JOIN이라고합니다.

* 다음 SQL문은 고객과 주문번호를 선택하여 나타냅니다. LEFT JOIN 키워드는 오른쪽 테이블 (Orders)에 일치하는 항목이 없더라도 왼쪽 테이블 (Customers)의 모든 레코드를 반환합니다.(일치하는 CustomersID값을 기준으로 Orders.OrdesID정보를 가져옵니다. 일치하는 CustomersID가 없는 Customers테이블의 값들은 Orders.OrdesID에 Null이 할당됩니다.)
```
SELECT Customers.CustomerName, Orders.OrderID
FROM Customers
LEFT JOIN Orders ON Customers.CustomerID = Orders.CustomerID
ORDER BY Customers.CustomerName;
```

### SQL RIGHT JOIN키워드
* RRIGHT JOIN키워드는 오른쪽 테이블의 모든 레코드와 외쪽테이블의 일치 레코들을 반환합니다. 일치하는 것이 없으면 외쪽 테이블의 정보는 모두 Null값이 됩니다. RIGHT JOIN 키워드는 왼쪽 테이블 (Orders)에 일치하는 항목이 없더라도 오른쪽 테이블 (Employees)의 모든 레코드를 반환합니다.

* 다음 SQL문은 모든 직원 및 주문한 모든 주문을 반환합니다.
```
SELECT Orders.OrderID, Employees.LastName, Employees.FirstName
FROM Orders
RIGHT JOIN Employees ON Orders.EmployeeID = Employees.EmployeeID
ORDER BY Orders.OrderID;
```

### SQL FULL OUTER JOIN키워드
* FULL OUTER JOIN 키워드는 왼쪽 (table1) 또는 오른쪽 (table2) 테이블 레코드가 일치 할 때 모든 레코드를 리턴합니다. FULL OUTER JOIN은 잠재적으로 매우 큰 결과 집합을 반환 할 수 있습니다!

* 기본 사용법
```
SELECT column_name(s)
FROM table1
FULL OUTER JOIN table2 ON table1.column_name = table2.column_name;
```

* 다음 SQL문은 모든 고객의 이름과 모든 주믄을 선택합니다.
```
SELECT Customers.CustomerName, Orders.OrderID
FROM Customers
FULL OUTER JOIN Orders ON Customers.CustomerID=Orders.CustomerID
ORDER BY Customers.CustomerName;
```
FULL OUTER JOIN 키워드는 왼쪽 테이블 (Customers)의 모든 행과 오른쪽 테이블 (Orders)의 모든 행을 리턴합니다. '주문'에 일치하지 않는 행이 '고객'에 있거나 '고객'에 일치하지 않는 행이 '주문'에있는 경우 해당 행이 함께 표시됩니다.

### SELF JOIN문
* SELF JOIN문은 조인문이지만 자기 자신과 결합합니다. 실제로 자기 자신과의 결합이 아니라 그렇게 하는 것과 같은 효과를 가졌다는 겄을 말한다. 같은 테이블 안에서 여러가지 컬럼을 조건으로 하여 결과값을 가져오고 싶을 때 사용합니다.

* 기본 사용법
```
SELECT column_name(s)
FROM table1 T1, table1 T2
WHERE condition;
```

* 다음 SQL문은 같은 도시에서 온 고객들을 선택합니다.
```
SELECT A.CustomerName AS CustomerName1, B.CustomerName AS CustomerName2, A.City
FROM Customers A, Customers B
WHERE A.CustomerID <> B.CustomerID
AND A.City = B.City
ORDER BY A.City;
```

### SQL UNION연산자

* UNION 연산자는 두 개 이상의 SELECT 문의 결과를 결합하는 데 사용됩니다.

* UNION 연산자 사용조건
>UNION 내의 각 SELECT 문은 같은 수의 열을 가져야합니다.

>열은 유사한 데이터 형식을 가져야합니다.

>각 SELECT 문의 열은 같은 순서로 있어야합니다

* 기본 사용법
```
SELECT column_name(s) FROM table1
UNION
SELECT column_name(s) FROM table2;
```

* UNION 연산자는 기본적으로 고유 값만 선택합니다. 중복 값을 허용하려면 UNION ALL을 사용하십시오.
```
SELECT column_name(s) FROM table1
UNION ALL
SELECT column_name(s) FROM table2;
```

* 결과 집합의 열 이름은 일반적으로 UNION의 첫 번째 SELECT 문의 열 이름과 동일합니다.

* 다음 SQL문은 "Customers"W "Suppliers"에서 모든 다른 독일 도시 (유일한 값만)를 선택합니다.
```
SELECT City, Country FROM Customers
WHERE Country='Germany'
UNION
SELECT City, Country FROM Suppliers
WHERE Country='Germany'
ORDER BY City;
```

* 다음 SQL문은 "Customers"W "Suppliers"에서 모든 독일 도시 (중복 값 포함)를 선택합니다.
```
SELECT City, Country FROM Customers
WHERE Country='Germany'
UNION ALL
SELECT City, Country FROM Suppliers
WHERE Country='Germany'
ORDER BY City;
```

* 다음 SQL문은 모든 고객과 공급자를 나열합니다.
```
SELECT 'Customer' As Type, ContactName, City, Country
FROM Customers
UNION
SELECT 'Supplier', ContactName, City, Country
FROM Suppliers;
```

### SQL GROUP BY문
* GROUP BY문은 집계 함수 (COUNT, MAX, MIN, SUM, AVG)와 함께 사용되어 결과 집합을 하나 이상의 열로 그룹화 합니다.

* 기본 사용법
```
SELECT column_name(s)
FROM table_name
WHERE condition
GROUP BY column_name(s)
ORDER BY column_name(s);
```

* 다음 SQL 문은 각 국가의 고객 수를 나열합니다.
```
SELECT COUNT(CustomerID), Country
FROM Customers
GROUP BY Country;
```

* 다음 SQL 문은 각 국가의 고객 수를 내림차순으로 정렬하여 나열합니다.
```
SELECT COUNT(CustomerID), Country
FROM Customers
GROUP BY Country
ORDER BY COUNT(CustomerID) DESC;
```

* 다음 SQL 문은 각 발송인이 보낸 주문 수를 나열합니다.
```
SELECT Shippers.ShipperName, COUNT(Orders.OrderID) AS NumberOfOrders FROM Orders
LEFT JOIN Shippers ON Orders.ShipperID = Shippers.ShipperID
GROUP BY ShipperName;
```

### SQL HAVING Clause(HAVING절)
* HAVING절은 WHERE 키워드가 집합 함수(aggregate functions)와 함께 사용될 수 없기 때문에 SQL문에 추가되었습니다. (연산에 조건을 추가하여 더 세밀한 정보를 찾아낼 때 사용할 수 있다.)

* 기본 사용법
```
SELECT column_name(s)
FROM table_name
WHERE condition
GROUP BY column_name(s)
HAVING condition
ORDER BY column_name(s);
```

* 다음 SQL문은 각 국가의 고객 수를 나열합니다. 5 명 이상의 고객이있는 국가 만 포함
```
SELECT COUNT(CustomerID), Country
FROM Customers
GROUP BY Country
HAVING COUNT(CustomerID) > 5;
```

* 다음 SQL문은 각 국가의 고객 수를 높은 순으로 정렬하여 나열합니다 (고객이 5 명 이상인 국가 만 포함).
```
SELECT COUNT(CustomerID), Country
FROM Customers
GROUP BY Country
HAVING COUNT(CustomerID) > 5
ORDER BY COUNT(CustomerID) DESC;
```

* "Davolio"또는 "Fuller"직원이 25 개가 넘는 주문을 등록한 경우 다음 SQL 문에 나열됩니다.
```
SELECT Employees.LastName, COUNT(Orders.OrderID) AS NumberOfOrders
FROM Orders
INNER JOIN Employees ON Orders.EmployeeID = Employees.EmployeeID
WHERE LastName = 'Davolio' OR LastName = 'Fuller'
GROUP BY LastName
HAVING COUNT(Orders.OrderID) > 25;
```

### SQL EXISTS 연산자
* EXISTS 연산자는 하위 쿼리의 레코드 존재 여부를 테스트하는 데 사용됩니다. EXISTS 연산자는 하위 쿼리가 하나 이상의 레코드를 반환하면 true를 반환합니다.
```
SELECT column_name(s)
FROM table_name
WHERE EXISTS
(SELECT column_name FROM table_name WHERE condition);
```

* 다음 SQL 문은 TRUE를 반환하고 제품 가격이 20 미만인 공급 업체를 나열합니다.
```
SELECT SupplierName
FROM Suppliers
WHERE EXISTS (SELECT ProductName FROM Products WHERE SupplierId = Suppliers.supplierId AND Price < 20);
```

### SQL ANY 및 ALL 연산자
* ANY 및 ALL 연산자는 WHERE 또는 HAVING 절과 함 2 사용됩니다. ANY 연산자는 하위 쿼리 값 중 하나가 조건을 충족하면 true를 반환합니다. ALL 연산자는 모든 하위 쿼리 값이 조건을 충족하면 true를 반환합니다.

* ANY 구문 기본 사용법
```
SELECT column_name(s)
FROM table_name
WHERE column_name operator ANY
(SELECT column_name FROM table_name WHERE condition);
```

* ALL 구문 기본 사용법
```
SELECT column_name(s)
FROM table_name
WHERE column_name operator ALL
(SELECT column_name FROM table_name WHERE condition);
```

* 다음 SQL문은 TRUE를 리턴하고 OrderDetails 의 quantity = 10 인 값의 ProductID와 Products의 ProductID를 비교하여 같은 값이 있다면 Products의 ProductsName을 반환합니다.
```
SELECT ProductName
FROM Products
WHERE ProductID = ANY (SELECT ProductID FROM OrderDetails WHERE Quantity = 10);
```

* OrderDetails 테이블의 모든 레코드가 quantity = 10이면 다음 SQL 문은 TRUE를 반환하고 제품 이름을 나열합니다.
```
SELECT ProductName
FROM Products
WHERE ProductID = ALL (SELECT ProductID FROM OrderDetails WHERE Quantity = 10);
```

### SQL SELECT INTO문
* SELECT INTO 문은 한 테이블의 데이터를 새 테이블로 복사합니다.

* 기본 사용법(모든 열을 새 테이블로 복사)
```
SELECT *
INTO newtable [IN externaldb]
FROM oldtable
WHERE condition;
```

* 기본 사용법(일부 열만 새 테이블로 복사)
```
SELECT column1, column2, column3, ...
INTO newtable [IN externaldb]
FROM oldtable
WHERE condition;
```

* 다음 SQL 문은 Customers 백업 복사본을 만듭니다.
```
SELECT * INTO CustomersBackup2017
FROM Customers;
```

* 다음 SQL 문은 IN 절을 사용하여 테이블을 다른 데이터베이스의 새 테이블로 복사합니다.
```
SELECT * INTO CustomersBackup2017 IN 'Backup.mdb'
FROM Customers;
```

* 다음 SQL 문은 몇 개의 열만 새 테이블에 복사합니다.
```
SELECT CustomerName, ContactName INTO CustomersBackup2017
FROM Customers;
```

* 다음 SQL 문은 독일 고객 만 새 테이블로 복사합니다.
```
SELECT * INTO CustomersGermany
FROM Customers
WHERE Country = 'Germany';
```

* 다음 SQL 문은 둘 이상의 테이블의 데이터를 새 테이블로 복사합니다.
```
SELECT Customers.CustomerName, Orders.OrderID
INTO CustomersOrderBackup2017
FROM Customers
LEFT JOIN Orders ON Customers.CustomerID = Orders.CustomerID;
```

* SELECT INTO를 사용하여 다른 테이블의 스키마를 사용하여 빈 테이블을 새로 만들 수도 있습니다. 쿼리가 데이터를 반환하지 않게하는 WHERE 절을 추가하기만 하면됩니다.
```
SELECT * INTO newtable
FROM oldtable
WHERE 1 = 0;
```

### SQL INSERT INTO SELECT문
* INSERT INTO SELECT 문은 한 테이블의 데이터를 복사하여 다른 테이블에 삽입합니다. INSERT INTO SELECT는 소스 및 목표 테이블의 데이터 유형이 일치해야합니다. 목표 테이블의 기존 레코드는 영향을받지 않습니다.

* 한 테이블의 모든 열을 다른 테이블로 복사
```
INSERT INTO table2
SELECT * FROM table1
WHERE condition;
```

* 한 테이블의 일부 열만 다른 테이블로 복사
```
INSERT INTO table2 (column1, column2, column3, ...)
SELECT column1, column2, column3, ...
FROM table1
WHERE condition;
```

### SQL NULL함수
예제 데이터
P_Id	|	ProductName	|	UnitPrice	|	UnitsInStock	|	UnitsOnOrder
---|---|---|---|---
1	|	Jarlsberg	|	10.45	|	16	|	15
2	|	Mascarpone	|	32.56	|	23	|
3	|	Gorgonzola	|	15.67	|	9	|	20

* "UnitsOnOrder"열이 선택적이며 NULL 값을 포함 할 수 있다고 가정합니다. 다음 SQL문에서는 위의 예제에서 위의 예제에서 "UnitsOnOrder"값 중 하나라도 NULL이면 결과는 NULL입니다.
```
SELECT ProductName, UnitPrice * (UnitsInStock + UnitsOnOrder)
FROM Products;
```

* MY SQL에서는 IFNULL()함수를 사용하거나 COALESCE() 함수를 사용하여 대체 값을 반환 할 수 있습니다.
```
SELECT ProductName, UnitPrice * (UnitsInStock + IFNULL(UnitsOnOrder, 0))
FROM Products
```
```
SELECT ProductName, UnitPrice * (UnitsInStock + COALESCE(UnitsOnOrder, 0))
FROM Products
```

* SQL서버에서는 ISNULL()함수를 사용하면 식이 NULL일 때 대체 값을 반환 할 수 있습니다.
```
SELECT ProductName, UnitPrice * (UnitsInStock + ISNULL(UnitsOnOrder, 0))
FROM Products
```

* MS Access IsNull()함수는 식이 null값이면 True(-1)를 반환하고 그렇지 않으면 FALSE(0)을 반환합니다.
```
SELECT ProductName, UnitPrice * (UnitsInStock + IIF(IsNull(UnitsOnOrder), 0, UnitsOnOrder))
FROM Products
```
Oracle NVL () 함수는 동일한 결과를 얻습니다.
```
SELECT ProductName, UnitPrice * (UnitsInStock + NVL(UnitsOnOrder, 0))
FROM Products
```

### SQL 주석
* 주석은 SQL 문의 섹션을 설명하거나 SQL 문의 실행을 막는 데 사용됩니다.

* 한 줄 주석은 `-`로 시작합니다. `-`와 행 끝 사이의 모든 텍스트는 무시됩니다 (실행되지 않습니다). 다음 예제는 한 줄 주석을 설명으로 사용합니다.
```
--Select all:
SELECT * FROM Customers;
```

* 다음 예제에서는 한 줄 주석을 사용하여 줄 끝을 무시합니다.
```
SELECT * FROM Customers -- WHERE City='Berlin';
```

* 여러 줄 주석은 `/*`로 시작하고 `*/`로 끝납니다. `/*`와 `*/` 사이의 모든 텍스트는 무시됩니다. 다음 예제에서는 설명을 위해 여러 줄 주석을 사용합니다.
```
/*Select all the columns
of all the records
in the Customers table:*/
SELECT * FROM Customers;
```

* 명령문의 일부만 무시하려면 `/*` `*/` 주석도 사용하십시오. 다음 예제에서는 주석을 사용하여 행의 일부를 무시합니다.
```
SELECT CustomerName, /*City,*/ Country FROM Customers;
```

# **SQL 데이터베이스 동작 관련 문법**

### CREATE DATABASE문
* CREATE DATABASE 문은 새 SQL 데이터베이스를 만드는 데 사용됩니다.
```
CREATE DATABASE databasename;
```

### DROP DATABASE문
* DROP DATABASE 문은 기존 SQL 데이터베이스를 삭제하는 데 사용됩니다.
```
DROP DATABASE databasename;
```

### CREATE TABLE문
* CREATE TABLE 문은 데이터베이스에 새 테이블을 만드는 데 사용됩니다.
> column 매개 변수는 테이블의 열 이름을 지정합니다.

> datatype 매개 변수는 열에서 보유 할 수있는 데이터 유형 (예 : varchar, 정수, 날짜 등)을 지정합니다.

```
CREATE TABLE table_name (
    column1 datatype,
    column2 datatype,
    column3 datatype,
   ....
);
```

* 다음 예에서는 PersonID, LastName, FirstName, Address 및 City라는 다섯 개의 열이 포함 된 "Persons"라는 테이블을 만듭니다.
```
CREATE TABLE Persons (
    PersonID int,
    LastName varchar(255),
    FirstName varchar(255),
    Address varchar(255),
    City varchar(255)
);
```
> PersonID 열은 int 유형이며 정수를 포함합니다.

>LastName, FirstName, Address 및 City 열은 varchar 유형이며 문자를 포함하며이 필드의 최대 길이는 255 자입니다.

빈 "Persons"테이블은 이제 다음과 같이 보입니다.

PersonID	|	LastName	|	FirstName	|	Address	|	City
---|---|---|---|---
---|---|---|---|---

* 다른 테이블을 사용하여 새 테이블을 만들 수 있습니다. 기존 테이블의 사본은 CREATE TABLE.과 SELECT.의 조합을 사용하여 작성할 수 있습니다. 테이블은 동일한 열 정의를 가져옵니다. 모든 열 또는 특정 열을 선택할 수 있습니다. 기존 테이블을 사용하여 새 테이블을 만들면 새 테이블은 이전 테이블의 기존 값으로 채워집니다.
```
CREATE TABLE new_table_name AS
    SELECT column1, column2,...
    FROM existing_table_name
    WHERE ....;
```

### DROP TABLE문
* DROP TABLE 문은 데이터베이스의 기존 테이블을 삭제하는 데 사용됩니다.
```
DROP TABLE table_name;
```

* TRUNCATE TABLE 문은 테이블 내부의 데이터는 삭제하지만 테이블 자체는 삭제하지 않습니다.
```
TRUNCATE TABLE table_name;
```

### ALTER TABLE문
* ALTER TABLE 문은 기존 테이블의 열을 추가, 삭제 또는 수정하는 데 사용됩니다. ALTER TABLE문은 기존 테이블에 다양한 제한 조건을 추가 제거하는 데에도 사용됩니다.
```
ALTER TABLE table_name
ADD column_name datatype;
```

* 테이블의 열을 삭제하려면 다음 구문을 사용합니다 (일부 데이터베이스 시스템에서는 열 삭제가 허용되지 않음).
```
ALTER TABLE table_name
DROP COLUMN column_name;
```
* 테이블에있는 열의 데이터 형식을 변경하려면 다음 구문을 사용합니다.

SQL Server / MS 액세스
```
ALTER TABLE table_name
ALTER COLUMN column_name datatype;
```

내 SQL / 오라클 (이전 버전 10G) :
```
ALTER TABLE table_name
MODIFY COLUMN column_name datatype;
```

Oracle 10G 이상
```
ALTER TABLE table_name
MODIFY column_name datatype;
```

### SQL Constraints

* SQL 제한 조건은 테이블의 데이터에 대한 특정한 룰을 지정하는 데 사용됩니다.

* CREATE TABLE.으로 테이블이 작성 될 때 또는 ALTER TABLE.으로 테이블이 작성된 후에 제한 조건을 지정할 수 있습니다.
```
CREATE TABLE table_name (
    column1 datatype constraint,
    column2 datatype constraint,
    column3 datatype constraint,
    ....
);
```
* SQL 제약 조건은 테이블의 데이터에 대한 규칙을 지정하는 데 사용됩니다.
제약 조건은 테이블에 들어갈 수있는 데이터 유형을 제한하는 데 사용됩니다. 이렇게하면 표의 데이터 정확성과 신뢰성이 보장됩니다. 제한 조건과 데이터 조치 사이에 위반이 있으면 조치가 중단됩니다.
제약 조건은 열 수준 또는 테이블 수준 일 수 있습니다. 컬럼 레벨 제한 조건은 컬럼에 적용되고 테이블 레벨 제한 조건은 전체 테이블에 적용됩니다.
SQL에서 일반적으로 사용되는 다음 제약 조건이 있습니다.


```
NOT NULL - 열이 NULL 값을 가질 수 없음을 보장합니다.
UNIQUE - 열의 모든 값이 서로 다른지 확인합니다.
PRIMARY KEY - NOT NULL과 UNIQUE의 조합. 테이블의 각 행을 고유하게 식별합니다.
FOREIGN KEY - 다른 테이블의 행 / 레코드를 고유하게 식별합니다.
CHECK - 열의 모든 값이 특정 조건을 충족하는지 확인합니다.
DEFAULT - 값이 지정되지 않은 경우 열의 기본값을 설정합니다.
INDEX - 데이터베이스에서 데이터를 매우 신속하게 생성 및 검색하는 데 사용됩니다.
```

### SQL NOT NULL 제약 조건

* 기본적으로 열은 NULL 값을 포함 할 수 있습니다. NOT NULL 제약 조건은 열이 NULL 값을 허용하지 않도록 강제합니다. 이렇게하면 필드에 항상 값이 포함될 수 있습니다. 즉, 새 레코드를 삽입하거나이 필드에 값을 추가하지 않고 레코드를 업데이트 할 수 없습니다.

* 다음 SQL은 "ID", "LastName"및 "FirstName"열이 NULL 값을 허용하지 않도록합니다.
```
CREATE TABLE Persons (
    ID int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255) NOT NULL,
    Age int
);
```

### SQL UNIQUE 제약 조건

* UNIQUE 제약 조건은 열의 모든 값이 서로 다른지 확인합니다. UNIQUE 및 PRIMARY KEY 제약 조건은 열 또는 열 집합의 고유성을 보장합니다. PRIMARY KEY 제약 조건에는 자동으로 UNIQUE 제약 조건이 있습니다. 그러나 테이블 당 많은 UNIQUE 제약 조건을 가질 수 있지만 테이블 당 하나의 PRIMARY KEY 제약 조건 만 가질 수 있습니다.

* 다음 SQL은 "Person"테이블을 만들 때 "ID"열에 UNIQUE 제약 조건을 만듭니다.
SQL Server / Oracle / MS 액세스
```
CREATE TABLE Persons (
    ID int NOT NULL UNIQUE,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Age int
);
```
MySQL
```
CREATE TABLE Persons (
    ID int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Age int,
    UNIQUE (ID)
);
```

* UNIQUE 제약 조건의 이름을 지정하고 여러 열에 UNIQUE 제약 조건을 정의하려면 다음 SQL 구문을 사용하십시오.
```
CREATE TABLE Persons (
    ID int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Age int,
    CONSTRAINT UC_Person UNIQUE (ID,LastName)
);
```

* 테이블이 이미 만들어 졌을 때 "ID"열에 UNIQUE 제약 조건을 만들려면 다음 SQL을 사용하십시오.
```
ALTER TABLE Persons
ADD UNIQUE (ID);
```

* UNIQUE 제약 조건의 이름을 지정하고 여러 열에 UNIQUE 제약 조건을 정의하려면 다음 SQL 구문을 사용하십시오.
```
ALTER TABLE Persons
ADD CONSTRAINT UC_Person UNIQUE (ID,LastName);
```

* UNIQUE 제약 조건을 삭제하려면 다음 SQL을 사용하십시오.
MySQL
```
ALTER TABLE Persons
DROP INDEX UC_Person;
```

SQL Server / Oracle / MS 액세스
```
ALTER TABLE Persons
DROP CONSTRAINT UC_Person;
```

### SQL PRIMARY KEY제약

* PRIMARY KEY 제약 조건은 데이터베이스 테이블의 각 레코드를 고유하게 식별합니다. (각 레코드를 식별해 주는 고유한 값으로 보면 된다.)
* 기본 키는 UNIQUE 값을 포함해야하며 NULL 값을 포함 할 수 없습니다.
* 테이블에는 기본 키가 하나만있을 수 있습니다.
* 기본 키는 하나 또는 여러 개의 필드로 구성 될 수 있습니다.

* 다음 SQL문은 "Person"테이블이 생성 될 때 "ID"열에 PRIMARY KEY를 만듭니다.

MySQL
```
CREATE TABLE Persons (
    ID int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Age int,
    PRIMARY KEY (ID)
);
```
SQL Server / Oracle / MS 액세스
```
CREATE TABLE Persons (
    ID int NOT NULL PRIMARY KEY,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Age int
);
```

* PRIMARY KEY 제약 조건의 이름 지정을 허용하고 여러 열에 대해 PRIMARY KEY 제약 조건을 정의하려면 다음 SQL 구문을 사용합니다. (참고 : 다음 예에서는 오직 하나의 PRIMARY KEY (PK_Person) 만 있습니다. 그러나 기본 키의 VALUE는 두 개의 COLUMNS (ID + 성)로 구성됩니다.)
```
CREATE TABLE Persons (
    ID int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Age int,
    CONSTRAINT PK_Person PRIMARY KEY (ID,LastName)
);
```

* 테이블이 이미 만들어 졌을 때 "ID"열에 PRIMARY KEY 제약 조건을 만들려면 다음 SQL을 사용하십시오.
```
ALTER TABLE Persons
ADD PRIMARY KEY (ID);
```

* PRIMARY KEY 제약 조건의 이름 지정을 허용하고 여러 열에 대해 PRIMARY KEY 제약 조건을 정의하려면 다음 SQL 구문을 사용합니다.
```
ALTER TABLE Persons
ADD CONSTRAINT PK_Person PRIMARY KEY (ID,LastName);
```

* ALTER TABLE 문을 사용하여 PRIMARY KEY를 추가하는 경우 PRIMARY KEY 열은 (테이블이 처음 작성되었을 때) NULL 값을 포함하지 않도록 이미 선언되어 있어야합니다.

* PRIMARY KEY 제약 조건을 삭제하려면 다음 SQL을 사용하십시오.
MySQL
```
ALTER TABLE Persons
DROP PRIMARY KEY;
```

SQL Server / Oracle / MS 액세스
```
ALTER TABLE Persons
DROP CONSTRAINT PK_Person;
```

### SQL FOREIGN KEY제약

* FOREIGN KEY는 두 테이블을 서로 연결하는 데 사용되는 키입니다.
* FOREIGN KEY는 다른 테이블의 PRIMARY KEY를 참조하는 테이블의 필드 (또는 필드 모음)입니다.
* FOREIGN KEY가 들어있는 테이블을 하위 테이블이라고하고 candidate key가 들어있는 테이블을 참조 된 테이블 또는 상위 테이블이라고합니다.

Persons  table
PersonID	|	LastName	|	FirstName	|	Age
---|---|---|---
1	|	Hansen	|	Ola	|	30
2	|	Svendson	|	Tove	|	23
3	|	Pettersen	|	Kari	|	20

Orders table
OrderID	|	OrderNumber	|	PersonID
---|---|---
1	|	77895	|	3
2	|	44678	|	3
3	|	22456	|	2
4	|	24562	|	1

* "Orders"테이블의 "PersonID"열이 "Person"테이블의 "PersonID"열을 가리키는 것을 확인하십시오.
* "Person"테이블의 "PersonID"열은 "Person"테이블의 PRIMARY KEY입니다.
* "Orders"테이블의 "PersonID"열은 "Orders"테이블의 FOREIGN KEY입니다.
* FOREIGN KEY 제약 조건은 테이블 간의 연결을 파괴하는 작업을 방지하는 데 사용됩니다.
* FOREIGN KEY 제약 조건은 또한 가리키는 테이블에 포함 된 값 중 하나 여야하기 때문에 잘못된 데이터가 외부 키 열에 삽입되는 것을 방지합니다.

* 다음 SQL문은 "Orders"테이블을 만들 때 "PersonID"열에 FOREIGN KEY를 만듭니다.
MySQL
```
CREATE TABLE Orders (
    OrderID int NOT NULL,
    OrderNumber int NOT NULL,
    PersonID int,
    PRIMARY KEY (OrderID),
    FOREIGN KEY (PersonID) REFERENCES Persons(PersonID)
);
```
SQL Server / Oracle / MS 액세스
```
CREATE TABLE Orders (
    OrderID int NOT NULL PRIMARY KEY,
    OrderNumber int NOT NULL,
    PersonID int FOREIGN KEY REFERENCES Persons(PersonID)
);
```

* FOREIGN KEY 제약 조건의 이름 지정 및 여러 열의 FOREIGN KEY 제약 조건 정의를 허용하려면 다음 SQL 구문을 사용합니다.
```
CREATE TABLE Orders (
    OrderID int NOT NULL,
    OrderNumber int NOT NULL,
    PersonID int,
    PRIMARY KEY (OrderID),
    CONSTRAINT FK_PersonOrder FOREIGN KEY (PersonID)
    REFERENCES Persons(PersonID)
);
```

* "Orders"테이블이 이미 생성 된 경우 "PersonID"열에 FOREIGN KEY 제약 조건을 만들려면 다음 SQL을 사용하십시오.
```
ALTER TABLE Orders
ADD FOREIGN KEY (PersonID) REFERENCES Persons(PersonID);
```

* FOREIGN KEY 제약 조건의 이름 지정 및 여러 열의 FOREIGN KEY 제약 조건 정의를 허용하려면 다음 SQL 구문을 사용합니다.
```
ALTER TABLE Orders
ADD CONSTRAINT FK_PersonOrder
FOREIGN KEY (PersonID) REFERENCES Persons(PersonID);
```

* FOREIGN KEY 제약 조건을 삭제하려면 다음 SQL을 사용하십시오.
MySQL
```
ALTER TABLE Orders
DROP FOREIGN KEY FK_PersonOrder;
```

SQL Server / Oracle / MS 액세스
```
ALTER TABLE Orders
DROP CONSTRAINT FK_PersonOrder;
```

### SQL CHECK Constraint

* CHECK 제약 조건은 열에 배치 할 수있는 값 범위를 제한하는 데 사용됩니다.
* 단일 열에 CHECK 제한 조건을 정의하면이 열에 대해 특정 값만 허용됩니다.
* 테이블에 CHECK 제한 조건을 정의하면 행의 다른 컬럼에있는 값을 기준으로 특정 컬럼의 값을 제한 할 수 있습니다.

* 다음 SQL은 "Person"테이블이 작성 될 때 "Age"컬럼에 CHECK 제한 조건을 작성합니다. CHECK 제약 조건은 18 세 미만의 사람을 가질 수 없도록 보장합니다.
MySQL
```
CREATE TABLE Persons (
    ID int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Age int,
    CHECK (Age>=18)
);
```

SQL Server / Oracle / MS 액세스
```
CREATE TABLE Persons (
    ID int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Age int CHECK (Age>=18)
);
```

* CHECK 제약 조건의 이름 지정 및 여러 열에 대한 CHECK 제약 조건 정의를 허용하려면 다음 SQL 구문을 사용하십시오.
```
CREATE TABLE Persons (
    ID int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Age int,
    City varchar(255),
    CONSTRAINT CHK_Person CHECK (Age>=18 AND City='Sandnes')
);
```

* 테이블이 이미 생성 된 경우 "Age"열에 CHECK 제약 조건을 만들려면 다음 SQL을 사용하십시오.
```
ALTER TABLE Persons
ADD CHECK (Age>=18);
```

* CHECK 제약 조건의 이름 지정 및 여러 열에 대한 CHECK 제약 조건 정의를 허용하려면 다음 SQL 구문을 사용하십시오.
```
ALTER TABLE Persons
ADD CONSTRAINT CHK_PersonAge CHECK (Age>=18 AND City='Sandnes');
```

* CHECK 제약 조건을 삭제하려면 다음 SQL을 사용하십시오.
SQL Server / Oracle / MS 액세스
```
ALTER TABLE Persons
DROP CONSTRAINT CHK_PersonAge;
```

MySQL
```
ALTER TABLE Persons
DROP CHECK CHK_PersonAge;
```

### DEFAULT Constraint

* DEFAULT 제약 조건은 열의 기본값을 제공하는 데 사용됩니다.
* 다른 값을 지정하지 않으면 기본값이 모든 새 레코드에 추가됩니다.

* 다음 SQL은 "Person"테이블을 만들 때 "City"열의 DEFAULT 값을 설정합니다.
```
CREATE TABLE Persons (
    ID int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Age int,
    City varchar(255) DEFAULT 'Sandnes'
);
```

* DEFAULT 제약 조건은 GETDATE ()와 같은 함수를 사용하여 시스템 값을 삽입하는 데에도 사용할 수 있습니다.
```
CREATE TABLE Orders (
    ID int NOT NULL,
    OrderNumber int NOT NULL,
    OrderDate date DEFAULT GETDATE()
);
```

* 테이블이 이미 만들어 졌을 때 "도시"열에 DEFAULT 제약 조건을 만들려면 다음 SQL을 사용하십시오
MySQL
```
ALTER TABLE Persons
ALTER City SET DEFAULT 'Sandnes';
```

SQL Server / MS Access:
```
ALTER TABLE Persons
ALTER COLUMN City SET DEFAULT 'Sandnes';
```

Oracle
```
ALTER TABLE Persons
MODIFY City DEFAULT 'Sandnes';
```

* DEFAULT 제약 조건을 삭제하려면 다음 SQL을 사용합니다.

MySQL
```
ALTER TABLE Persons
ALTER City DROP DEFAULT;
```

Server / Oracle / MS 액세스
```
ALTER TABLE Persons
ALTER COLUMN City DROP DEFAULT;
```

### CREATE INDEX문

* DEX 문은 테이블에 인덱스를 만드는 데 사용됩니다.
* 인덱스는 데이터베이스에서 데이터를 매우 빨리 검색하는 데 사용됩니다. 사용자는 색인을 볼 수 없으며 검색 / 쿼리의 속도를 높이기 위해 사용됩니다.
* 인텍스와 함께 테이블을 갱신하는 것은 테이블만 갱신하는 것 보다 많은 시간을 잡아먹습니다. 따라서 자주 검색 할 열에 대해서만 인덱스를 작성하십시오.

* 테이블에 인덱스를 만듭니다. 중복 된 값이 허용됩니다.
```
CREATE INDEX index_name
ON table_name (column1, column2, ...);
```

* 테이블에 고유 인덱스를 작성합니다. 중복 값은 허용되지 않습니다.
```
CREATE UNIQUE INDEX index_name
ON table_name (column1, column2, ...);
```

* 참고 : 인덱스를 만드는 구문은 데이터베이스마다 다릅니다. 따라서 데이터베이스의 인덱스 작성 구문을 확인하십시오.

* DROP INDEX 문은 테이블의 인덱스를 삭제하는 데 사용됩니다.
MS 액세스
```
DROP INDEX index_name ON table_name;
```
SQL Server
```
DROP INDEX table_name.index_name;
```
DB2 / Oracle
```
P INDEX index_name;
```
MySQL
```
ALTER TABLE table_name
DROP INDEX index_name;
```

### INCREMENT 필드

* AUTO INCREMENT 필드 : 자동 증가는 새 레코드가 테이블에 삽입 될 때 고유 번호가 자동으로 생성되도록합니다. 종종 이것은 새로운 레코드가 삽입 될 때마다 자동으로 생성되기를 원하는 기본 키 필드입니다.

* MySQL : 다음 SQL 문은 "Person"테이블의 자동 증가 기본 키 필드로 "ID"열을 정의합니다. MySQL은 AUTO_INCREMENT 키워드를 사용하여 자동 증가 기능을 수행합니다. 기본적으로 AUTO_INCREMENT의 시작 값은 1이며 새 레코드마다 1 씩 증가합니다.
```
CREATE TABLE Persons (
    ID int NOT NULL AUTO_INCREMENT,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Age int,
    PRIMARY KEY (ID)
);
```
AUTO_INCREMENT 시퀀스를 다른 값으로 시작하려면 다음 SQL 문을 사용하십시오.
```
ALTER TABLE Persons AUTO_INCREMENT=100;
```
"Persons"테이블에 새 레코드를 삽입하려면 "ID"열에 값을 지정할 필요가 없습니다 (고유 한 값이 자동으로 추가됩니다).
```
INSERT INTO Persons (FirstName,LastName)
VALUES ('Lars','Monsen');
```

* SQL Server구문 : 다음 SQL 문은 "Person"테이블의 자동 증가 기본 키 필드로 "ID"열을 정의합니다. MS SQL Server는 IDENTITY 키워드를 사용하여 자동 증가 기능을 수행합니다. 위의 예에서 IDENTITY의 시작 값은 1이며 새 레코드마다 1 씩 증가합니다.
```
CREATE TABLE Persons (
    ID int IDENTITY(1,1) PRIMARY KEY,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Age int
);
```
팁 : "ID"열이 값 10에서 시작하여 5 씩 증가하도록 지정하려면 IDENTITY (10,5)로 변경하십시오.

* "Persons"테이블에 새 레코드를 삽입하려면 "ID"열에 값을 지정할 필요가 없습니다 (고유 한 값이 자동으로 추가됩니다).
```
INSERT INTO Persons (FirstName,LastName)
VALUES ('Lars','Monsen');
```

* Access : 다음 SQL 문은 "Person"테이블의 자동 증가 기본 키 필드로 "ID"열을 정의합니다. MS Access는 AUTOINCREMENT 키워드를 사용하여 자동 증가 기능을 수행합니다. 기본적으로 AUTOINCREMENT의 시작 값은 1이며 새 레코드마다 1 씩 증가합니다.
```
CREATE TABLE Persons (
    ID Integer PRIMARY KEY AUTOINCREMENT,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Age int
);
```
팁 : "ID"열이 값 10에서 시작하여 5 씩 증가하도록 지정하려면 자동 증가를 AUTOINCREMENT (10,5)로 변경하십시오.

* "Persons"테이블에 새 레코드를 삽입하려면 "ID"열에 값을 지정할 필요가 없습니다 (고유 한 값이 자동으로 추가됩니다).
```
INSERT INTO Persons (FirstName,LastName)
VALUES ('Lars','Monsen');
```

* 오라클 : 오라클에서는 코드가 좀 더 까다 롭습니다. 시퀀스 객체로 자동 증가 필드를 만들어야합니다 (이 객체는 숫자 시퀀스를 생성합니다).
```
CREATE SEQUENCE seq_person
MINVALUE 1
START WITH 1
INCREMENT BY 1
CACHE 10;
```
위의 코드는 seq_person이라는 시퀀스 객체를 생성합니다. seq_person은 1부터 시작하여 1 씩 증가합니다. 또한 성능을 위해 최대 10 개의 값을 캐시합니다. 캐시 옵션은 더 빠른 액세스를 위해 얼마나 많은 순서 값이 메모리에 저장 될지 지정합니다.

* "Persons"테이블에 새 레코드를 삽입하려면 nextval 함수를 사용해야합니다 (이 함수는 seq_person 시퀀스에서 다음 값을 검색합니다).
```
INSERT INTO Persons (ID,FirstName,LastName)
VALUES (seq_person.nextval,'Lars','Monsen');
```

### SQL Date

* 날짜 작업을 할 때 가장 어려운 부분은 삽입하려는 날짜의 형식이 데이터베이스의 날짜 열 형식과 일치하는지 확인하는 것입니다.

* MySQL 에는 데이터베이스에 날짜 또는 날짜 / 시간 값을 저장하기위한 다음 데이터 유형이 있습니다.
```
DATE - YYYY-MM-DD 형식
DATETIME - 형식 : YYYY-MM-DD HH : MI : SS
TIMESTAMP - 형식 : YYYY-MM-DD HH : MI : SS
YEAR - YYYY 또는 YY 형식
```

* SQL Server 에는 데이터베이스에 날짜 또는 날짜 / 시간 값을 저장하기위한 다음 데이터 형식이 있습니다.
```
DATE - YYYY-MM-DD 형식
DATETIME - 형식 : YYYY-MM-DD HH : MI : SS
SMALLDATETIME - 형식 : YYYY-MM-DD HH : MI : SS
TIMESTAMP - 형식 : 고유 번호
```

다음 "Orders" 테이블이 있다고 가정합니다.
OrderId	|	ProductName	|	OrderDate
---|---|---
1	|	Geitost	|	2008-11-11
2	|	Camembert Pierrot	|	2008-11-09
3	|	Mozzarella di Giovanni	|	2008-11-11
4	|	Mascarpone Fabioli	|	2008-10-29

* 위 표에서 OrderDate가 "2008-11-11"인 레코드를 선택하려고합니다.
```
SELECT * FROM Orders WHERE OrderDate='2008-11-11'
```

이제 "주문"테이블이 다음과 같이 보입니다 ( "주문일"열의 시간 구성 요소에 주목하십시오).
OrderId	|	ProductName	|	OrderDate
---|---|---
1	|	Geitost	|	2008-11-11 13:23
2	|	Camembert Pierrot	|	2008-11-09 15:45
3	|	Mozzarella di Giovanni	|	2008-11-11 11:12
4	|	Mascarpone Fabioli	|	2008-10-29 14:56

* 위와 같은 SELECT 문을 사용하는 경우 `SELECT * FROM Orders WHERE OrderDate='2008-11-11'` 우리는 결과를 얻지 못할 것이다! 이는 쿼리가 시간 부분이없는 날짜 만 찾고 있기 때문입니다.

* 팁 : 검색어를 간단하고 쉽게 유지하려면 날짜에 시간 구성 요소를 허용하지 마십시오!

### SQL CREATE VIEW문

* SQL에서 뷰는 SQL 문의 결과 세트를 기반으로하는 가상 테이블입니다.
* 뷰에는 실제 테이블과 마찬가지로 행과 열이 포함됩니다. 뷰의 필드는 데이터베이스에있는 하나 이상의 실제 테이블의 필드입니다.
* SQL 함수, WHERE 및 JOIN 문을 뷰에 추가하고 데이터가 하나의 단일 테이블에서 온 것처럼 데이터를 표시 할 수 있습니다.

* 기본 사용법
```
CREATE VIEW view_name AS
SELECT column1, column2, ...
FROM table_name
WHERE condition;
```
참고 : 보기에는 항상 최신 데이터가 표시됩니다! 데이터베이스 엔진은 사용자가 뷰를 쿼리 할 때마다 뷰의 SQL 문을 사용하여 데이터를 다시 작성합니다.

* "현재 제품 목록"보기에는 "제품"테이블의 모든 활성 제품 (중단되지 않은 제품)이 나열됩니다. 뷰는 다음 SQL로 작성됩니다.
```
CREATE VIEW [Current Product List] AS
SELECT ProductID, ProductName
FROM Products
WHERE Discontinued = No;
```
그런 다음 다음과 같이 뷰를 쿼리 할 수 ​​있습니다.
```
SELECT * FROM [Current Product List];
```

* Northwind 샘플 데이터베이스의 또 다른보기는 "제품"테이블의 모든 제품을 평균 단가보다 높은 단가로 선택합니다.
```
CREATE VIEW [Products Above Average Price] AS
SELECT ProductName, UnitPrice
FROM Products
WHERE UnitPrice > (SELECT AVG(UnitPrice) FROM Products);
```
위의보기는 다음과 같이 쿼리 할 수 ​​있습니다.
```
SELECT * FROM [Products Above Average Price];
```

* Northwind 데이터베이스의 다른보기는 1997 년 각 범주의 총 ​​판매량을 계산합니다.이보기는 "1997 년 제품 판매"라는 다른보기에서 해당 데이터를 선택합니다.
```
CREATE VIEW [Category Sales For 1997] AS
SELECT DISTINCT CategoryName, Sum(ProductSales) AS CategorySales
FROM [Product Sales for 1997]
GROUP BY CategoryName;
```
위의보기는 다음과 같이 쿼리 할 수 ​​있습니다.
```
SELECT * FROM [Category Sales For 1997];
```
쿼리에 조건을 추가 할 수도 있습니다. "음료수"카테고리에 대해서만 총 판매를 봅시다.
```
SELECT * FROM [Category Sales For 1997]
WHERE CategoryName = 'Beverages';
```

### SQL VIEW UPDATE

* 기본 사용법
```
CREATE OR REPLACE VIEW view_name AS
SELECT column1, column2, ...
FROM table_name
WHERE condition;
```

* 다음 예시는 위의 "현재 제품 목록" VIEW에 "범주"열을 추가합니다. 다음 SQL로 뷰를 업데이트합니다.
```
CREATE OR REPLACE VIEW [Current Product List] AS
SELECT ProductID, ProductName, Category
FROM Products
WHERE Discontinued = No;
```

* VIEW 삭제 : 다음 SQL 명령으로 VIEW를 삭제할 수 있습니다.
```
DROP VIEW view_name;
```

### SQL INJECTION (추가공부 필요)
* SQL INJECTION은 데이터베이스를 파괴 할 수있는 코드 삽입 기술입니다.
* SQL INJECTION은 가장 일반적인 웹 해킹 기술 중 하나입니다.
* SQL INJECTION은 웹 페이지 입력을 통해 SQL 문에 악의적 인 코드를 배치합니다.
* SQL 인젝션은 대개 사용자에게 username / userid와 같은 입력을 요청할 때 발생하며 이름 / ID 대신 사용자가 알지 못하게 데이터베이스에서 실행할 SQL 문을 제공 합니다.


### SQL Hosting
* 웹 사이트에서 데이터베이스의 데이터를 저장하고 검색 할 수있게하려면 웹 서버가 SQL 언어를 사용하는 데이터베이스 시스템에 액세스 할 수 있어야합니다.
* 웹 서버가 ISP (Internet Service Provider)에 의해 호스팅되는 경우 SQL 호스팅 계획을 찾아야합니다.
* 가장 일반적인 SQL 호스팅 데이터베이스는 MS SQL Server, Oracle, MySQL 및 MS Access입니다.
* Microsoft의 SQL Server는 트래픽이 많은 데이터베이스 중심 웹 사이트에 널리 사용되는 데이터베이스 소프트웨어입니다. SQL Server는 강력하고 완벽한 SQL 데이터베이스 시스템입니다.
* 오라클은 트래픽이 많은 데이터베이스 중심 웹 사이트에 널리 사용되는 데이터베이스 소프트웨어이기도합니다.
* MySQL은 웹 사이트에 널리 사용되는 데이터베이스 소프트웨어이기도합니다. MySQL은 값 비싼 Microsoft 및 Oracle 솔루션 대신 저렴한 방법입니다.
