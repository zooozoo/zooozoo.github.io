<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Spanning multi-valued relationships | HOME</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Spanning multi-valued relationships" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="장고의 모델 문서를 공부하다가(Making Queries) 이전에 패캠에서 수업들을 때 한번 이해 했던 내용인데 다시보니 너무 헷갈려서 폭풍써치를 감행했고 비로소 이해를 하게 되었다. (하… 내 시간…)" />
<meta property="og:description" content="장고의 모델 문서를 공부하다가(Making Queries) 이전에 패캠에서 수업들을 때 한번 이해 했던 내용인데 다시보니 너무 헷갈려서 폭풍써치를 감행했고 비로소 이해를 하게 되었다. (하… 내 시간…)" />
<link rel="canonical" href="/2018-01-24/Django_Spanning-multi-valued-relationships" />
<meta property="og:url" content="/2018-01-24/Django_Spanning-multi-valued-relationships" />
<meta property="og:site_name" content="HOME" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-01-24T00:00:00+00:00" />
<script type="application/ld+json">
{"description":"장고의 모델 문서를 공부하다가(Making Queries) 이전에 패캠에서 수업들을 때 한번 이해 했던 내용인데 다시보니 너무 헷갈려서 폭풍써치를 감행했고 비로소 이해를 하게 되었다. (하… 내 시간…)","@type":"BlogPosting","url":"/2018-01-24/Django_Spanning-multi-valued-relationships","headline":"Spanning multi-valued relationships","dateModified":"2018-01-24T00:00:00+00:00","datePublished":"2018-01-24T00:00:00+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018-01-24/Django_Spanning-multi-valued-relationships"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


  <!-- CSS -->
  <link rel="stylesheet" href="/assets/main.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">

  <!-- Favicon -->
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png">

  <!-- RSS -->
  <link type="application/atom+xml" rel="alternate" href="/feed.xml" title="HOME" />

  <!-- Google Analytics-->
  
</head>


  <body>

    <nav class="nav">
  <div class="nav-container">
    <a href="/">
      <h2 class="nav-title">HOME</h2>
    </a>
    <ul>
      <li><a href="/post/">POSTS</a></li>
      <li><a href="/record/">RECORDS</a></li>
      <li><a href="/tis/">TIS</a></li>
      <li><a href="/about">ABOUT</a></li>
    </ul>
  </div>
</nav>

    <main>
      <div class="post">
  <div class="post-info">
    <span>Written by</span>
    
        
    

    
      <br>
      <span>on&nbsp;</span><time datetime="2018-01-24 00:00:00 +0000">January 24, 2018</time>
    
  </div>

  <h1 class="post-title">Spanning multi-valued relationships</h1>
  <div class="post-line"></div>

  <p>장고의 모델 문서를 공부하다가<a href="https://docs.djangoproject.com/ko/1.11/topics/db/queries/#spanning-multi-valued-relationships">(Making Queries)</a> 이전에 패캠에서 수업들을 때 한번 이해 했던 내용인데 다시보니 너무 헷갈려서 폭풍써치를 감행했고 비로소 이해를 하게 되었다. (하… 내 시간…)</p>

<p>해당 내용을 이미 알고 있고 스압을 느끼신다면 <a href="https://stackoverflow.com/questions/5542874/difference-between-filter-with-multiple-arguments-and-chain-filter-in-django">stackoverflow 의 답변</a>으로 바로 가보시길…</p>

<p>해당 부분은 <code class="highlighter-rouge">Spanning multi-valued relationships</code> 라는 부분인데 ForeignKey나 Many-to-Many관계에있는 모델중에서 관계된 모델을 조건으로 해서 filtering 하는 내용이다.</p>

<p>장고 문서에서는 아래의 모델을 기준으로 설명한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">django.db</span> <span class="kn">import</span> <span class="n">models</span>

<span class="k">class</span> <span class="nc">Blog</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
    <span class="n">tagline</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">TextField</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

<span class="k">class</span> <span class="nc">Author</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
    <span class="n">email</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">EmailField</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

<span class="k">class</span> <span class="nc">Entry</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">blog</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span><span class="n">Blog</span><span class="p">,</span> <span class="n">on_delete</span><span class="o">=</span><span class="n">models</span><span class="o">.</span><span class="n">CASCADE</span><span class="p">)</span>
    <span class="n">headline</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">255</span><span class="p">)</span>
    <span class="n">body_text</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">TextField</span><span class="p">()</span>
    <span class="n">pub_date</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">DateField</span><span class="p">()</span>
    <span class="n">mod_date</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">DateField</span><span class="p">()</span>
    <span class="n">authors</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ManyToManyField</span><span class="p">(</span><span class="n">Author</span><span class="p">)</span>
    <span class="n">n_comments</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">IntegerField</span><span class="p">()</span>
    <span class="n">n_pingbacks</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">IntegerField</span><span class="p">()</span>
    <span class="n">rating</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">IntegerField</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">headline</span>
</code></pre></div></div>

<p>해당 모델은 Blog (일) &lt; - &gt; (다) Entry &lt; - &gt; (다)Author 의 관계를 가지고 있다.</p>

<p>다음은 장고 문서에서 설명하는 내용</p>

<blockquote>
  <p>To handle both of these situations, Django has a consistent way of processing <a href="https://docs.djangoproject.com/ko/1.11/ref/models/querysets/#django.db.models.query.QuerySet.filter"><code class="highlighter-rouge">filter()</code></a> calls. Everything inside a single <a href="https://docs.djangoproject.com/ko/1.11/ref/models/querysets/#django.db.models.query.QuerySet.filter"><code class="highlighter-rouge">filter()</code></a> call is applied simultaneously to filter out items matching all those requirements. Successive <a href="https://docs.djangoproject.com/ko/1.11/ref/models/querysets/#django.db.models.query.QuerySet.filter"><code class="highlighter-rouge">filter()</code></a> calls further restrict the set of objects, but for multi-valued relations, they apply to any object linked to the primary model, not necessarily those objects that were selected by an earlier <a href="https://docs.djangoproject.com/ko/1.11/ref/models/querysets/#django.db.models.query.QuerySet.filter"><code class="highlighter-rouge">filter()</code></a> call.</p>

  <p>That may sound a bit confusing, so hopefully an example will clarify. To select all blogs that contain entries with both <em>“Lennon”</em> in the headline and that were published in 2008 (the same entry satisfying both conditions), we would write:</p>

  <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">entry__headline__contains</span><span class="o">=</span><span class="s">'Lennon'</span><span class="p">,</span> <span class="n">entry__pub_date__year</span><span class="o">=</span><span class="mi">2008</span><span class="p">)</span>
</code></pre></div>  </div>

  <p>To select all blogs that contain an entry with <em>“Lennon”</em> in the headline <strong>as well as</strong> an entry that was published in 2008, we would write:</p>

  <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">entry__headline__contains</span><span class="o">=</span><span class="s">'Lennon'</span><span class="p">)</span><span class="o">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">entry__pub_date__year</span><span class="o">=</span><span class="mi">2008</span><span class="p">)</span>
</code></pre></div>  </div>

  <p>Suppose there is only one blog that had both entries containing <em>“Lennon”</em> and entries from 2008, but that none of the entries from 2008 contained <em>“Lennon”</em>. The first query would not return any blogs, but the second query would return that one blog.</p>

  <p>In the second example, the first filter restricts the queryset to all those blogs linked to entries with <em>“Lennon”</em> in the headline. The second filter restricts the set of blogs <em>further</em> to those that are also linked to entries that were published in 2008. The entries selected by the second filter may or may not be the same as the entries in the first filter. We are filtering the <code class="highlighter-rouge">Blog</code> items with each filter statement, not the <code class="highlighter-rouge">Entry</code> items.</p>
</blockquote>

<p>요약해서 설명하자면</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">entry__headline__contains</span><span class="o">=</span><span class="s">'Lennon'</span><span class="p">,</span> <span class="n">entry__pub_date__year</span><span class="o">=</span><span class="mi">2008</span><span class="p">)</span>
</code></pre></div></div>

<p>와 같이 필터 안에 여러개의 조건을 써서 찾는 것과</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">entry__headline__contains</span><span class="o">=</span><span class="s">'Lennon'</span><span class="p">)</span><span class="o">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">entry__pub_date__year</span><span class="o">=</span><span class="mi">2008</span><span class="p">)</span>
</code></pre></div></div>

<p>이런식으로(chaining) 필터를 나눠서 각각 찾는것이 다른 결과를 가지며 그 이유는 결과가 Entry를 탐색하는 것이 아닌  Blog를 탐색하는 것이기 때문이라고 설명하고 있다.</p>

<p>두 번째 예시가 잘 이해되지 않았는데 만약 첫번째 filter로 blog 객체를 추려낸 후에 해당 결과를 가지고 두 번째 filter를 적용하면 어떻게 하든 첫 번째 예시와 같은 결과를 할 것 같다. 결국에 돌고 돌아 stackoverflow를 통해 내용을 이해할 수 있었다.</p>

<p>누군가 나랑 똑같은 질문을 stackoverflow에 했고 아주 상세한 설명이 있어서 덕분해 잘 이해할 수 있었다.</p>

<p>장고에 있는 문서보다는 <a href="https://stackoverflow.com/questions/5542874/difference-between-filter-with-multiple-arguments-and-chain-filter-in-django">stackoverflow 에 예시</a>로 쓰여진 내용이 훨씬 잘 이해 된다.</p>

<p>아래는 해당 답변 내용이다.</p>

<blockquote>
  <p>The case in which results of “multiple arguments filter-query” is different then “chained-filter-query”, following:</p>

  <blockquote>
    <p>Selecting referenced objects on the basis of referencing objects and relationship is one-to-many (or many-to-many).</p>

    <p>Multiple filters:</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">Referenced</span><span class="o">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">referencing1_a</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">referencing1_b</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>
<span class="c">#  same referencing model   ^^                ^^</span>
</code></pre></div>    </div>

    <p>Chained filters:</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Referenced</span><span class="o">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">referencing1_a</span><span class="o">=</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">referencing1_b</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>
</code></pre></div>    </div>

    <p>Both queries can output different result:
If more then one rows in referencing-model<code class="highlighter-rouge">Referencing1</code>can refer to same row in referenced-model<code class="highlighter-rouge">Referenced</code>. This can be the case in <code class="highlighter-rouge">Referenced</code>: <code class="highlighter-rouge">Referencing1</code> have either 1:N (one to many) or N:M (many to many) relation-ship.</p>
  </blockquote>

  <p>Example:</p>

  <p>Consider my application <code class="highlighter-rouge">my_company</code> has two models <code class="highlighter-rouge">Employee</code> and <code class="highlighter-rouge">Dependent</code>. An employee in <code class="highlighter-rouge">my_company</code> can have more than dependents(in other-words a dependent can be son/daughter of a single employee, while a employee can have more than one son/daughter).
Ehh, assuming like husband-wife both can’t work in a <code class="highlighter-rouge">my_company</code>. I took 1:m example</p>

  <p>So, <code class="highlighter-rouge">Employee</code> is referenced-model that can be referenced by more then <code class="highlighter-rouge">Dependent</code> that is referencing-model. Now consider relation-state as follows:</p>

  <blockquote>
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Employee:        Dependent:
+------+        +------+--------+-------------+--------------+
| name |        | name | E-name | school_mark | college_mark |
+------+        +------+--------+-------------+--------------+
| A    |        | a1   |   A    |          79 |           81 |
| B    |        | b1   |   B    |          80 |           60 |
+------+        | b2   |   B    |          68 |           86 |
                +------+--------+-------------+--------------+  
</code></pre></div>    </div>

    <p>Dependent<code class="highlighter-rouge">a1</code>refers to employee<code class="highlighter-rouge">A</code>, and dependent<code class="highlighter-rouge">b1, b2</code>references to employee<code class="highlighter-rouge">B</code>.</p>
  </blockquote>

  <p>Now my query is:</p>

  <p>Find all employees those having son/daughter has distinction marks (say &gt;= 75%) in both college and school?</p>

  <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">Employee</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">dependent__school_mark__gte</span><span class="o">=</span><span class="mi">75</span><span class="p">,</span>
<span class="o">...</span>                         <span class="n">dependent__college_mark__gte</span><span class="o">=</span><span class="mi">75</span><span class="p">)</span>

<span class="p">[</span><span class="o">&lt;</span><span class="n">Employee</span><span class="p">:</span> <span class="n">A</span><span class="o">&gt;</span><span class="p">]</span>
</code></pre></div>  </div>

  <p>Output is ‘A’ dependent ‘a1’ has distinction marks in both college and school is dependent on employee ‘A’. Note ‘B’ is not selected because nether of ‘B’’s child has distinction marks in both college and school. Relational algebra:</p>

  <blockquote>
    <p>Employee <strong>⋈</strong>(school_mark &gt;=75 AND college_mark&gt;=75)Dependent</p>
  </blockquote>

  <p>In Second, case I need a query:</p>

  <p>Find all employees whose some of dependents has distinction marks in college and school?</p>

  <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">Employee</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="nb">filter</span><span class="p">(</span>
<span class="o">...</span>             <span class="n">dependent__school_mark__gte</span><span class="o">=</span><span class="mi">75</span>
<span class="o">...</span>                <span class="p">)</span><span class="o">.</span><span class="nb">filter</span><span class="p">(</span>
<span class="o">...</span>             <span class="n">dependent__college_mark__gte</span><span class="o">=</span><span class="mi">75</span><span class="p">)</span>

<span class="p">[</span><span class="o">&lt;</span><span class="n">Employee</span><span class="p">:</span> <span class="n">A</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">Employee</span><span class="p">:</span> <span class="n">B</span><span class="o">&gt;</span><span class="p">]</span>
</code></pre></div>  </div>

  <p>This time ‘B’ also selected because ‘B’ has two children (more than one!), one has distinction mark in school ‘b1’ and other is has distinction mark in college ‘b2’.
Order of filter doesn’t matter we can also write above query as:</p>

  <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">Employee</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="nb">filter</span><span class="p">(</span>
<span class="o">...</span>             <span class="n">dependent__college_mark__gte</span><span class="o">=</span><span class="mi">75</span>
<span class="o">...</span>                <span class="p">)</span><span class="o">.</span><span class="nb">filter</span><span class="p">(</span>
<span class="o">...</span>             <span class="n">dependent__school_mark__gte</span><span class="o">=</span><span class="mi">75</span><span class="p">)</span>

<span class="p">[</span><span class="o">&lt;</span><span class="n">Employee</span><span class="p">:</span> <span class="n">A</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">Employee</span><span class="p">:</span> <span class="n">B</span><span class="o">&gt;</span><span class="p">]</span>
</code></pre></div>  </div>

  <p>result is same! Relational algebra can be:</p>

  <blockquote>
    <p>(Employee <strong>⋈</strong>(school_mark &gt;=75)Dependent) <strong>⋈</strong>(college_mark&gt;=75)Dependent</p>
  </blockquote>

  <p>Note following:</p>

  <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dq1</span> <span class="o">=</span> <span class="n">Dependent</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">college_mark__gte</span><span class="o">=</span><span class="mi">75</span><span class="p">,</span> <span class="n">school_mark__gte</span><span class="o">=</span><span class="mi">75</span><span class="p">)</span>
<span class="n">dq2</span> <span class="o">=</span> <span class="n">Dependent</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">college_mark__gte</span><span class="o">=</span><span class="mi">75</span><span class="p">)</span><span class="o">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">school_mark__gte</span><span class="o">=</span><span class="mi">75</span><span class="p">)</span>
</code></pre></div>  </div>

  <p>Outputs same result: <code class="highlighter-rouge">[&lt;Dependent: a1&gt;]</code></p>

  <p>I check target SQL query generated by Django using <code class="highlighter-rouge">print qd1.query</code> and <code class="highlighter-rouge">print qd2.query</code>both are same(Django 1.6).</p>

  <p>But semantically both are different to <em>me</em>. first looks like simple section σ<a href="Dependent">school_mark &gt;= 75 AND college_mark &gt;= 75</a> and second like slow nested query: σ<a href="σ[college_mark &gt;= 75](Dependent)">school_mark &gt;= 75</a>.</p>

  <p>If one need <a href="http://codepad.org/c6VODLRf">Code @codepad</a></p>

  <p>btw, it is given in documentation @<a href="https://docs.djangoproject.com/en/dev/topics/db/queries/#spanning-multi-valued-relationships">Spanning multi-valued relationships</a> I have just added an example, I think it will be helpful for someone new.</p>
</blockquote>

<p>스택오버플로우에 올라온 답변을 요약해 보자면</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">Employee</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">dependent__school_mark__gte</span><span class="o">=</span><span class="mi">75</span><span class="p">,</span>
<span class="o">...</span>                         <span class="n">dependent__college_mark__gte</span><span class="o">=</span><span class="mi">75</span><span class="p">)</span>

<span class="p">[</span><span class="o">&lt;</span><span class="n">Employee</span><span class="p">:</span> <span class="n">A</span><span class="o">&gt;</span><span class="p">]</span>
</code></pre></div></div>

<p>위와 같은 필터링은 dependent에서 두개의 조건을 동시에 만족하는 Employee를 찾는 것 이므로 결과는 Employee A가 된다.</p>

<p>반면에</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">Employee</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="nb">filter</span><span class="p">(</span>
<span class="o">...</span>             <span class="n">dependent__school_mark__gte</span><span class="o">=</span><span class="mi">75</span>
<span class="o">...</span>                <span class="p">)</span><span class="o">.</span><span class="nb">filter</span><span class="p">(</span>
<span class="o">...</span>             <span class="n">dependent__college_mark__gte</span><span class="o">=</span><span class="mi">75</span><span class="p">)</span>

<span class="p">[</span><span class="o">&lt;</span><span class="n">Employee</span><span class="p">:</span> <span class="n">A</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">Employee</span><span class="p">:</span> <span class="n">B</span><span class="o">&gt;</span><span class="p">]</span>
</code></pre></div></div>

<p>위의 경우 첫번째 필터에서 걸러지는 내용은 Employee A, B 가 된다.(왜냐하면 dependent 의 a1과 b1이 조건을 만족했기 때문이다. ) 두번째 필터가 포인트 인데 두번째 필터에서 college_mark가 75점 이상인 dependent를 가지고 있는 Employee를 다시 찾게되고 그 결과값도 Employee A, B가 된다. 왜냐하면 첫번째 필터에서 걸러진 후의 결과는 Employee A, B 이고 두번째 필터는 이 중에서 다시 college_mark가 75점 이상인 경우를 찾아내는 것인데  Employee B의 경우 college_mark가 75점 이상인 dependent b2 를 가지고 있기 때문이다.</p>

<p>즉 Employee B는 college_mark와 school_mark가 동시에 75점 이상인 dependent를 가지고 있지 않지만, school_mark가 75점 이상인 dependent b1과 college_mark가 75점 이상인 dependent b2 이렇게 두개의 dependent를 가지고 있기 때문에 두 번째 필터에서도 해당 조건을 만족하는 것 이다.</p>

<p>언뜻 생각하기에 혼동되는 부분이 두번째 필터를 생각할 때 dependent를 기준으로 생각하기 때문이다. 첫번째 필터에서 해당되는 dependent가 a1과 b1 이기 때문에 두번 째 필터에서 dependent a1, b1 이렇게 2개를 기준으로 필터링 해야할 것 같지만 Employee 기준으로 생각하면 첫번째 필터의 결과는 해당조건을 만족하는 dependent와 연결된 Employee가 되기 때문에  필터를 하기 전 과 후는 같은 상황이 된다.</p>

<p>이해하고 다시 적은 내용이지만 다시 생각해 봐도 글로 설명하는 것 보다 예시를 통해 이해하는 편이 훨씬 도움이 되는 듯 하다.</p>

<p>잘 이해가 안된다면 stackoverflow의 답변을 차근차근 읽어내려 간다면 충분히 이해할 수 있을 것 같다.</p>


</div>

<div class="pagination">
  
    <a href="/2018-03-03/URL%EA%B3%BCURI" class="left arrow">&#8592;</a>
  
  
    <a href="/2018-01-22/7%EC%9B%9409%EC%9D%BC~7%EC%9B%9413%EC%9D%BC" class="right arrow">&#8594;</a>
  

  <a href="#" class="top">Top</a>
</div>

    </main>

    <footer>
  <span>
    &copy; <time datetime="2020-02-25 22:41:48 +0000">2020</time> . Made with Jekyll using the <a href="https://github.com/chesterhow/tale/">Tale</a> theme.
  </span>
</footer>

  </body>
</html>
